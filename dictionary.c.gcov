        -:    0:Source:dictionary.c
        -:    0:Graph:dictionary.gcno
        -:    0:Data:dictionary.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "dictionary.h"
        -:    5:#include <string.h>
        -:    6:
        -:    7:
        -:    8:struct wlnode* wlRev(struct wlnode*);
        -:    9:void 
        1:   10:perr(char error[]) {
        -:   11:#define DEBUGP
        -:   12:#ifdef DEBUGP
        1:   13:  fprintf(stderr,"%s\n",error);
        -:   14:#endif
        1:   15:}
        -:   16:
        -:   17:/* 
        -:   18:  unused functions
        -:   19:  used as a basis for the final functions :)
        -:   20:    */
        -:   21:
        -:   22:void printEdge(struct dictEdge* dnode, long n);
    #####:   23:void printDict(struct dictionary* dict) {
    #####:   24:  printEdge(dict->root,0);
    #####:   25:}
        -:   26:
        -:   27:#if 0
        -:   28:void 
        -:   29:dictList(struct dictionary* dict);
        -:   30:
        -:   31:void 
        -:   32:dictListN(struct dictEdge* root,char* word,int level);
        -:   33:
        -:   34:void 
        -:   35:dictList(struct dictionary* dict) {
        -:   36:  dictListN(dict->root,NULL,0);
        -:   37:}
        -:   38:
        -:   39:void dictListN(struct dictEdge* root,char* word,int level) {
        -:   40:  if (root == NULL)
        -:   41:    return;
        -:   42:  printf("%p\n",root);
        -:   43:  // word
        -:   44:  /*
        -:   45:  if (root->isTerminal == True) {
        -:   46:    printf("ISTERMINAL PRINTING OUT WORD len(%d)\n",strlen(word));
        -:   47:    printf("%s\n",word);
        -:   48:  } */
        -:   49:
        -:   50:  dictListN(root->sibling,word,level);
        -:   51: // if (root->thisChar == 0)
        -:   52: // return; 
        -:   53:  assert(root->thisChar != '\0');
        -:   54:
        -:   55:  if (word == NULL) {
        -:   56://    word = malloc(sizeof(char)*2);
        -:   57:    word = malloc(sizeof(char)*82);
        -:   58:    assert(word != NULL);
        -:   59:    // *word = sprintf("%c\0",root->thisChar);
        -:   60:    word[0] = root->thisChar;
        -:   61:    // printf(">%c<",root->thisChar);
        -:   62:    word[1] = 0;
        -:   63:  } else {
        -:   64:    int i = level + 2; // the array size is strlen(word)+1
        -:   65://    word = realloc (word, sizeof(char)*(i));
        -:   66:    word[i-1] = 0;
        -:   67:    word[i-2] = root->thisChar;
        -:   68://    printf("ATTEMPTING TO REALLOC for >%c<",root->thisChar);
        -:   69:    // add the char to the end of word, and/or move the pointer:)
        -:   70:    // printf("%d vs %d\n",i,strlen(word));
        -:   71:  }
        -:   72:  if (root->isTerminal == True) {
        -:   73:    printf("ISTERMINAL PRINTING OUT WORD len(%d)\n",strlen(word));
        -:   74:    printf("%s\n",word);
        -:   75:  }
        -:   76:  dictListN(root->child,word,level+1);
        -:   77:}
        -:   78:#endif
        -:   79:/* begining of true functions */
        -:   80:
        -:   81:// insert into slist and return the head
        -:   82:struct wlnode* 
        -:   83:wlIns(struct wlnode* head,char* word);
        -:   84:
        -:   85:// oop, typo :)
        -:   86:struct wlnode*
        -:   87:distCompletions (struct dictionary* dict,char* word);
        -:   88:void
        -:   89:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:   90:  int level, struct wlnode* head);
        -:   91:
        -:   92:// converts all the items in a dictionary into a linked list of words
        -:   93:// this isn't that bad
        -:   94:void
       67:   95:dictToWlNew (struct dictEdge* root,char *store,
        -:   96:  int level, struct wlnode* head) {
       67:   97:  if (root == NULL) 
       34:   98:    return;// terminating case :)
       33:   99:  assert(store != NULL); // store should be defined already
       33:  100:  int i = level + 2; 
       33:  101:  store[i-1] = 0;
       33:  102:  store[i-2] = root->thisChar;
       33:  103:  if (root->isTerminal == True) {
        8:  104:    char *str = malloc(sizeof(char)*(level + 2)); 
        -:  105:    // space for new char + null
        8:  106:    assert(str != NULL); // we have enough memory
        8:  107:    strcpy(str,store); // copy everything
        8:  108:    wlIns(head,str);
        -:  109:  } // do it in order :)
       33:  110:  dictToWlNew (root->child,store,level+1,head);
       33:  111:  dictToWlNew (root->sibling,store,level,head);
        -:  112:}
        -:  113:
        -:  114:struct wlnode*
        1:  115:distCompletions (struct dictionary* dict,char* word) {
        -:  116://  printf("strlen of word is %d\n",strlen(word));return;
        1:  117:  struct wlnode* a = wlIns(NULL,"hi");
        -:  118:  char store[82];
        1:  119:  store[0] = 0; // do I need this?
        -:  120:  // this is stupid
        1:  121:  if (word[0] == 0) { // meaning that the word is blank
        -:  122:    // printf("doing old routine");
        1:  123:    dictToWlNew(dict->root,store,0,a);
        -:  124:  //  return a->next;
        -:  125:  }
        -:  126:  else {
    #####:  127:    distCompletionsN(dict->root,word,store,0,a);
        -:  128:  }
        -:  129:  // if I want to see where the gap is between words
        1:  130:  struct wlnode* re = a->next;
        1:  131:  a->next = NULL;
        1:  132:  free(a);
        1:  133:  return re;
        -:  134:}
        -:  135:
        -:  136:void
    #####:  137:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:  138:  int level, struct wlnode* head) {
    #####:  139:  if (root == NULL) {
        -:  140:    // if the root is null we are done!
    #####:  141:    return;
        -:  142:  }
    #####:  143:  assert(store != NULL); // since I declared it before
    #####:  144:  int i = level + 2; // the array size is strlen(word)+1
    #####:  145:  store[i-1] = 0;
    #####:  146:  store[i-2] = root->thisChar; 
        -:  147:  // what this does is append root->thisChar to then end of stored string
        -:  148:  // FIX
    #####:  149:  if (root->isTerminal == True) {
    #####:  150:    if (strlen(word) - 1 == level) {
    #####:  151:      if (word[level] == root->thisChar) {
    #####:  152:        char *str = malloc(sizeof(char)*(level + 2));
    #####:  153:        assert(str != NULL);
    #####:  154:        strcpy(str,store);
    #####:  155:        head = wlIns(head,str);
        -:  156:      }
        -:  157:    }
        -:  158:  }
        -:  159:/*
        -:  160:  if (root->isTerminal == True) {
        -:  161:    if (strlen(word) - level == 1 && word[level] == root->thisChar) {
        -:  162:      printf("maybe I should add %s level: %d\n",word,level);
        -:  163:    }
        -:  164:  } */
    #####:  165:  if (root->isTerminal == True 
    #####:  166:    && (word[level] == root->thisChar || level >= strlen(word))
    #####:  167:    && (level >= strlen(word) )) { 
        -:  168:    
    #####:  169:    if (strlen(store) == 0) {
    #####:  170:      return; // since the string is empty, we don't add it
        -:  171:    }
        -:  172:    // printf("adding store %s\n",store);
        -:  173:    // printf("adding str %s %p len: %d\n",str,str,strlen(str));
    #####:  174:    char *str = malloc(sizeof(char)*(level + 2));
    #####:  175:    assert(str != NULL);
    #####:  176:    strcpy(str,store);
    #####:  177:    head = wlIns(head,str);
        -:  178:  } // just because we added a word doesn't mean we're finished!
    #####:  179:  if (level < strlen(word) && word[level] == root->thisChar) {
        -:  180:    // printf("we have a hit for %c!\n",word[level]);
    #####:  181:    distCompletionsN (root->child,word,store,level+1,head);
    #####:  182:  } else if (level >=strlen(word)) {
        -:  183:    // printf("here");
    #####:  184:    distCompletionsN (root->child,word,store,level+1,head);
        -:  185:    // since I add child first, it is in ORDER :)
    #####:  186:    distCompletionsN (root->sibling,word,store,level,head);
        -:  187:  } else {
    #####:  188:    distCompletionsN (root->sibling,word,store,level,head);
        -:  189:  } 
        -:  190:  /* these three cases
        -:  191:
        -:  192:  */
        -:  193:}
        -:  194:// just to test out a few algorithms.
        -:  195:struct wlnode* 
        -:  196:wlIns(struct wlnode* head,char* word);
        -:  197:void 
        -:  198:insertWordR (struct dictEdge * node, char* word);
        -:  199:bool
        -:  200:dictLookupN (struct dictEdge* node,char* word) ;
        -:  201:void
        -:  202:edgeFree(struct dictEdge *node);
        -:  203:struct dictEdge* dictEdgeNew(char thisChar);
        -:  204:void 
        -:  205:printDict(struct dictionary *dict);
        -:  206:
        -:  207:/* Initialise the dictionary structure
        -:  208: */
        -:  209:struct dictionary*
        1:  210:dictInit () {
        -:  211:  // we create a new dictionary and then we return it
        1:  212:  struct dictionary* ndict = malloc(sizeof(struct dictionary));
        1:  213:  assert(ndict != NULL); 
        1:  214:  ndict->root = NULL;
        1:  215:  return ndict;
        -:  216:}
        -:  217:
        -:  218:struct dictEdge* 
       33:  219:dictEdgeNew(char thisChar) {
       33:  220:  struct dictEdge *ndictEdge = malloc(sizeof(struct dictEdge));
       33:  221:  assert(ndictEdge != NULL);
       33:  222:  ndictEdge->thisChar = thisChar;
       33:  223:  ndictEdge->child = NULL;
       33:  224:  ndictEdge->sibling = NULL;
       33:  225:  ndictEdge->isTerminal = 0;
       33:  226:  return ndictEdge;
        -:  227:}
        -:  228:    
    #####:  229:void printEdge(struct dictEdge* dnode, long n) {
    #####:  230:  if (dnode == NULL) {
    #####:  231:    return;
        -:  232:  }
        -:  233:  int i;
    #####:  234:  for (i=0;i != n;++i)
    #####:  235:    printf("  ");
        -:  236:  
    #####:  237:  if (dnode->isTerminal == True) {
    #####:  238:    printf("\033[1;33m%c\033[m\n",dnode->thisChar);
        -:  239:  } else {
    #####:  240:    printf("%c\n",dnode->thisChar);
        -:  241:
        -:  242:  }
    #####:  243:  printEdge(dnode->child, n+1); 
    #####:  244:  printEdge(dnode->sibling,n);
        -:  245:}
        -:  246:
        -:  247:/* Insert a single word into the dictionary 
        -:  248: */
        -:  249:void
        8:  250:dictInsertWord (struct dictionary* dict, char* word) {
        -:  251:  // assume I'm not in the list.
        8:  252:  if (dict->root == NULL) {
        1:  253:    dict->root = dictEdgeNew(word[0]);
        -:  254:  }
        -:  255:// todo this code still seems bugged like fuck
        -:  256:  // oh my this is icky
        -:  257:  // well, I suppose it's required though
        8:  258:  if (dict->root->thisChar > word[0]) {
        1:  259:    perr("noes :( fixing node");
        1:  260:    struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  261:    newp->sibling = dict->root;
        1:  262:    dict->root = newp;
        -:  263:  } // TODO, make sure this won't leave any extra nodes
        -:  264://  printf("comparing %d with %d\n",dict->root->thisChar,word[0]);
        8:  265:  assert(dict->root->thisChar <= word[0]); // make sure that the root is okay :)
        8:  266:  insertWordR (dict->root, word); 
        8:  267:}
        -:  268:
        -:  269:
        -:  270:// the amount of time this takes is dependant both on size of word and size of trie
        -:  271:
        -:  272:void 
       25:  273:insertWordR (struct dictEdge * node, char* word) {
       25:  274:  assert(node != NULL);
        -:  275:  // oh I remember again, to prevent against sloppy code ;)
        -:  276:  // passing a null edge is silly
        -:  277:
        -:  278:  /*
        -:  279:  if (word[1] == 0) {
        -:  280:    node->isTerminal = True;
        -:  281:  } */
        -:  282:  // FIX
        -:  283:  // Forgot about insert in order
        -:  284:  /*
        -:  285:  if (word[0] == 0) {
        -:  286:    // terminating
        -:  287:    printf("a triggering\n");
        -:  288:    node->isTerminal = True;
        -:  289:    return;
        -:  290:  }
        -:  291:  */
        -:  292:  // I do believe that kitten's algorithm was a lot better
        -:  293:  //printf("input string-> %s\n",word);
        -:  294:  //char first = word[0];
       25:  295:  bool found = False;
       25:  296:  struct dictEdge* roverPapa = NULL;
        -:  297:  //stopping case, word[0] == \0 // this is a lie!
        -:  298:
       25:  299:  if (word[0] != '\0') {
       25:  300:    struct dictEdge* rover = node;
        -:  301:  
       25:  302:    if (node->thisChar > word[0]) {
    #####:  303:      perr("we have a fucking problem");
    #####:  304:      assert(1 == 0);
        -:  305:    }
        -:  306:
       85:  307:    while (rover != NULL && !found) {
        -:  308:      // we search until we find a match or not
        -:  309:// new
       36:  310:      if (rover->thisChar > word[0]) {
        -:  311:        // ie it's not in the list, since we assume it's ordered
        -:  312:
        -:  313:        // insert it in order
        1:  314:        assert(roverPapa != NULL);
        1:  315:        struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  316:        roverPapa->sibling = newp;
        1:  317:        newp->sibling = rover;
        -:  318:        
        -:  319:        // recurse.
        1:  320:        if (word[1] == 0) {
    #####:  321:          newp->isTerminal = True;
        -:  322:        } else {       
        1:  323:          struct dictEdge* newcp = dictEdgeNew(word[1]);
        1:  324:          newp->child = newcp;
        1:  325:          insertWordR(newcp,&word[1]);
        -:  326:        }
        1:  327:        return;
        -:  328:
        -:  329:      }
       35:  330:      if (rover->thisChar == word[0]) {
       20:  331:        found = True;
        -:  332:        // printf("FOUND YAY");
        -:  333:      } else {
       15:  334:        roverPapa = rover;
       15:  335:        rover = rover->sibling;
        -:  336:      }
        -:  337:    }
        -:  338:    // we add it to the end ;)
       24:  339:    if (found == False) { // not found :) && not placed in order
        4:  340:      fprintf(stderr,"not found with arg %s\n",word);
        -:  341:      // just add the whole word in.
        4:  342:      rover = node; 
       11:  343:      while (rover->sibling != NULL) {
        3:  344:        rover = rover->sibling;
        -:  345:      }
        4:  346:      rover->sibling = dictEdgeNew(word[0]);
        4:  347:      node = rover->sibling;
        -:  348:
        4:  349:      int i = 1;
       21:  350:      while (word[i] != 0) {
       13:  351:        struct dictEdge* rover = node;
        -:  352:        int j;
        -:  353:        // terrible code
        -:  354:        // TODO
       35:  355:        for (j=0;j<i-1;j++) {
       22:  356:          assert(rover->child != NULL);
       22:  357:          rover = rover->child;
        -:  358:        }
       13:  359:        rover->child = dictEdgeNew(word[i]);      
        -:  360:     //  printf("new child pointing to %p\n",rover->child);
       13:  361:         ++i;
       13:  362:         if (word[i] == '\0') {
        4:  363:           rover->child->isTerminal = True;
        -:  364:         }
        -:  365:       }
        4:  366:       if (i == 1) { // bug fix.
        -:  367:       // we didn't enter loop
        -:  368:       // then the node is the final element
    #####:  369:         node->isTerminal = True;
        -:  370:       } // seems to make sense to put this at the front :) 
        -:  371:       // case for notentering the loop
        -:  372:     }
        -:  373:     else { 
        -:  374:      // found == True
        -:  375:      // looks like a bug here;
       20:  376:      if (rover->child != NULL) {
        5:  377:        if (word[1] == '\0') { 
    #####:  378:           printf("HERE"); // tc3 goes here
    #####:  379:           rover->isTerminal = True; 
        -:  380:        }
        -:  381:        else {
        -:  382:          // new FIX
        -:  383:          // inorderFix, create the node and set the pointer
        5:  384:          if (rover->child->thisChar > word[1]) {
        -:  385:            // we need to create
        1:  386:            struct dictEdge* newp = dictEdgeNew(word[1]);
        1:  387:            newp->sibling = rover->child;
        1:  388:            rover->child = newp;
        -:  389:          }
        5:  390:          insertWordR(rover->child,&word[1]); 
        -:  391:        }
        -:  392:      }
        -:  393:      else {
        -:  394:        //printf("->>%s\n",word);
       15:  395:        if (word[1] == '\0') { 
        4:  396:           rover->isTerminal = True;
        -:  397:        }
        -:  398:        else {
       11:  399:           rover->child = dictEdgeNew(word[1]);
       11:  400:           insertWordR(rover->child,&word[1]);
        -:  401:           // this could be done with a forloop
        -:  402:           // since all we're doing is spawning children
        -:  403:        }
        -:  404:      }
        -:  405:    }
        -:  406:  }
        -:  407:}
        -:  408:
        -:  409:/* Insert a list of words into the dictionary 
        -:  410: */
        -:  411:void
    #####:  412:dictInsertWords (struct dictionary* dict, struct wlnode* words) {
        -:  413:  // FIX
    #####:  414:  while (words != NULL) {
    #####:  415:    dictInsertWord(dict,words->word);
    #####:  416:    words = words->next;
        -:  417:  }
    #####:  418:}
        -:  419:
        -:  420:/* Check whether a given word is in the dictionary
        -:  421: */
        -:  422:bool
       14:  423:dictLookup (struct dictionary* dict, char* word) {
        -:  424:  // is there a more efficient way.
        -:  425:  // by using two loops, this can be implemented
        -:  426:  // thanks to Ian Craig who showed me :)
       14:  427:  assert(dict != NULL);
       14:  428:  return dictLookupN(dict->root,word);
        -:  429:}
        -:  430:
        -:  431:// n for internal? new?
        -:  432:bool
       54:  433:dictLookupN (struct dictEdge* node,char* word) {
        -:  434:  // todo this code still seems bugged like fuck
        -:  435:  // terminating case. // dictionary/word is NULL/\0
       54:  436:  if (node == NULL) {
        -:  437:    // very special case, dictionary is empty, clearly not in dictionary
    #####:  438:    return False;
        -:  439:  }
       54:  440:  if (word[0] == 0) { // shouldn't really go in here... 
    #####:  441:    return False;
        -:  442:  }
        -:  443:
       54:  444:  if (word[1] == '\0') {  // if it's the last letter
        9:  445:      struct dictEdge *rover = node;
        -:  446:      //printf("searching for %c %c\n",word[0],rover->thisChar);
        -:  447:      // while (word[0] < rover->thisChar && rover->sibling != NULL) 
        -:  448:      // while (rover->sibling != NULL && word[0] < rover->thisChar) // damn I had this, it's broken so badly 
       20:  449:      while (rover->sibling != NULL && word[0] > rover->thisChar) 
        -:  450:      {
        -:  451:        // and then it took me a while to figure why it's rover->sibling not rover
        -:  452:        // wow, terrible coding, I didn't even think of the first 
        -:  453:        // check
        -:  454:        //printf("PASS\n");
        2:  455:        rover = rover->sibling;
        -:  456:      }
        9:  457:      if (word[0] == rover->thisChar && rover->isTerminal == True) {
        4:  458:        return True;
        -:  459:      }
        -:  460:      // bugged here
        5:  461:      return False;
        -:  462:  }
       45:  463:  struct dictEdge *rover = node;
      127:  464:  while (rover != NULL) { 
       78:  465:    if (word[0] == rover->thisChar) {
        -:  466:      // if we are here we know that word[1] != 0
        -:  467:      // therefore we have not finished
        -:  468:      // rover child could be null
       41:  469:      if (rover->child == NULL) {
        1:  470:        return False; // no more children, therefore it can't be found
        -:  471:      }
       40:  472:      return dictLookupN(rover->child,&word[1]);
        -:  473:    } else {
       37:  474:      rover = rover->sibling;
        -:  475:    }
        -:  476:  }
        -:  477:  // if it gets here it means no matches in the siblings
        4:  478:  return False;
        -:  479:}
        -:  480:
        -:  481:bool
       14:  482:dictLookupIter (struct dictionary* dict, char* word) {
       14:  483:  int i = 0; // loop through elements of the word
       14:  484:  struct dictEdge* node = dict->root;
        -:  485:  struct dictEdge* rover;
       91:  486:  while (i != strlen(word)) {
      267:  487:    for (rover = node;
        -:  488:      rover != NULL;
      133:  489:      rover = rover->sibling) {
        -:  490:      // set node
        -:  491:      // if equal
      137:  492:      if (word[i] == rover->thisChar) {
       48:  493:        if (word[i + 1] == 0) {
        7:  494:          if (rover->isTerminal) {
        4:  495:            return True;
        -:  496:          }
        -:  497:        }
       44:  498:        node = rover->child;
        -:  499:        // break out of loop
        -:  500:      }
        -:  501:    }
       63:  502:    ++i; // look up the next letter with parent node
        -:  503:  }
        -:  504:  // if (word[i+1]) == 
        -:  505:  //while (word[1] != 
        -:  506:
       10:  507:  return False;
        -:  508:}
        -:  509:
        -:  510:/* Extract all words in the dictionary (the order does not matter).
        -:  511: * Should return them in alphabetical order
        -:  512: * Complexity: see constraint in the assignment specification.
        -:  513: */
        -:  514:struct wlnode*
        1:  515:dictCompletions (struct dictionary* dict, char* word) {
        1:  516:  return wlRev(distCompletions(dict,word)); // fun fix
        -:  517:  return distCompletions(dict,word);
        -:  518:}
        -:  519:
        -:  520:/* testing functions for the above */
        -:  521:void
    #####:  522:printwl (struct wlnode* wl) {
        -:  523:   struct wlnode * cur;
    #####:  524:   for (cur = wl; NULL != cur; cur =  cur->next)
    #####:  525:      fprintf (stdout, "%s\n", cur->word);
        -:  526:#if 0
        -:  527:  /*
        -:  528:   struct wlnode * cur;
        -:  529:   for (cur = wl; NULL != cur; cur =  cur->next)
        -:  530:      fprintf (stdout, "%s\n", cur->word);
        -:  531:      */
        -:  532:   struct wlnode * cur;
        -:  533:   cur = wl;
        -:  534:   //while (cur != NULL && cur != 0x65646e61) {
        -:  535:   while (cur != NULL) { 
        -:  536:       cur = cur->next;
        -:  537:       printf("cur %p\n",cur);
        -:  538:   }
        -:  539:   //return;
        -:  540:   //for (cur = wl; NULL != cur && cur != 0x65646e61; cur = cur->next)
        -:  541:   for (cur = wl; NULL != cur; cur = cur->next)
        -:  542:     fprintf (stdout, "%s %p\n", cur->word, cur->word);
        -:  543:#endif
    #####:  544:}
        -:  545:
        -:  546:
        -:  547:/* Erase all dictionary entries and release all memory allocated for the
        -:  548: * dictionary.
        -:  549: */
        -:  550:// Complexity O(n) // linearly dependant on size of trie
        -:  551:void
        1:  552:dictFree (struct dictionary* dict) {
        -:  553:  // the plan, free all the nodes then free the dictionary :)
        1:  554:  edgeFree(dict->root);
        1:  555:  free(dict); // freeing the dictionary is easy
        1:  556:}
        -:  557:
        -:  558:// internal call
        -:  559:// recursively free all the nodes
        -:  560:// Complexity O(n) // linearly dependant on size of trie
        -:  561:void
       67:  562:edgeFree(struct dictEdge *node) {
       67:  563:  if (node != NULL) {   
       33:  564:    edgeFree(node->sibling);
       33:  565:    edgeFree(node->child);
       33:  566:    node->sibling = NULL;
       33:  567:    node->child = NULL;
       33:  568:    free(node);
        -:  569:  }
       67:  570:}
        -:  571:
        -:  572:/* Return the root of the trie (i.e. dictionary). 
        -:  573: * If the dictionary is empty, then return NULL. 
        -:  574: * Otherwise, return the root of the trie. 
        -:  575: */ // complexity O(1)
        -:  576:struct dictEdge*
    #####:  577:dictGetRoot (struct dictionary* dict) { 
    #####:  578:  return dict->root;
        -:  579:}
        -:  580:
        -:  581:// word list functions below :)
        -:  582:/*
        -:  583:struct wlnode* 
        -:  584:wlIns (struct wlnode* wl, char* word) {
        -:  585:  struct wlnode* new = malloc(sizeof(struct wlnode));
        -:  586:  // something about this routine looks strange to me :$
        -:  587:  assert(new != NULL);
        -:  588:  new->word = word;
        -:  589:  new->next = NULL;
        -:  590:  if (wl == NULL) {
        -:  591:    wl = new;
        -:  592:  }
        -:  593:  else {
        -:  594:    struct wlnode* rover = wl; // coming back to this, I
        -:  595:    // was just thinking, what the heck am I doing here ;D
        -:  596:    // since there was no requirement for it to be ordered
        -:  597:    while (rover->next != NULL) {
        -:  598:      rover = rover->next;
        -:  599:    }
        -:  600:    rover->next = new;
        -:  601:  }
        -:  602:  return wl;
        -:  603:}*/
        -:  604:
        -:  605:/* This function does NOT do what it says on the tin */
        -:  606:// due to the fact that the initial complexity was O(n)
        -:  607:// Complexity, O(1)
        -:  608:// I was thinking of moving the mallocing to this function but then thought
        -:  609:// I might break something
        -:  610:/* This function inserts a word by reference in the second position, (or first if wlnode is NULL */
        -:  611:struct wlnode* 
       25:  612:wlIns (struct wlnode* wl, char* word) {
       25:  613:  struct wlnode* new = malloc(sizeof(struct wlnode));
       25:  614:  assert(new != NULL);
        -:  615:  // since we store the first node with dictCompletion
       25:  616:  new->word = word;
       25:  617:  if (wl == NULL) {
        4:  618:    new->next = wl;
        4:  619:    wl = new;
        -:  620:  }
        -:  621:  else {
       21:  622:    new->next = wl->next;
       21:  623:    wl->next = new;
        -:  624:  }
       25:  625:  return wl;
        -:  626:}
        -:  627:// Operation Complexity O(n)
        -:  628:// Space Requirement, O(1)
        -:  629:// In place reversing of a linked list
        2:  630:struct wlnode* wlRev(struct wlnode* wl) {
        -:  631:  // done in lab 1
        2:  632:  struct wlnode* new = wlIns(NULL,"");
        2:  633:  struct wlnode* rover = wl;
       26:  634:  while (rover != NULL) {
       22:  635:    struct wlnode* store = rover->next; 
        -:  636:      // do I get better performance if I store this variable outside the loop?
       22:  637:    rover->next = new->next;
       22:  638:    new->next = rover;
       22:  639:    rover = store; 
        -:  640:  }
        2:  641:  rover = new->next; // saves defining another variable :)
        2:  642:  new->next = NULL;
        2:  643:  free(new);
        2:  644:  return rover;
        -:  645:}
        -:  646:
        -:  647://unused
        -:  648:// Complexity O(n)
        -:  649:void
    #####:  650:wlfree (struct wlnode* wl) {
    #####:  651:  if (wl == NULL) {
    #####:  652:    return;
        -:  653:  }
    #####:  654:  wlfree(wl->next);
    #####:  655:  free(wl);
        -:  656:}
