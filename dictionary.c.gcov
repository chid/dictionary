        -:    0:Source:dictionary.c
        -:    0:Graph:dictionary.gcno
        -:    0:Data:dictionary.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "dictionary.h"
        -:    5:#include <string.h>
        -:    6:
        -:    7:
        -:    8:struct wlnode* wlRev(struct wlnode*);
        -:    9:void 
        1:   10:perr(char error[]) {
        -:   11:#define DEBUGP
        -:   12:#ifdef DEBUGP
        1:   13:  fprintf(stderr,"%s\n",error);
        -:   14:#endif
        1:   15:}
        -:   16:
        -:   17:/* 
        -:   18:  unused functions
        -:   19:  used as a basis for the final functions :)
        -:   20:    */
        -:   21:
        -:   22:void printEdge(struct dictEdge* dnode, long n);
    #####:   23:void printDict(struct dictionary* dict) {
    #####:   24:  printEdge(dict->root,0);
    #####:   25:}
        -:   26:
        -:   27:#if 0
        -:   28:void 
        -:   29:dictList(struct dictionary* dict);
        -:   30:
        -:   31:void 
        -:   32:dictListN(struct dictEdge* root,char* word,int level);
        -:   33:
        -:   34:void 
        -:   35:dictList(struct dictionary* dict) {
        -:   36:  dictListN(dict->root,NULL,0);
        -:   37:}
        -:   38:
        -:   39:void dictListN(struct dictEdge* root,char* word,int level) {
        -:   40:  if (root == NULL)
        -:   41:    return;
        -:   42:  printf("%p\n",root);
        -:   43:  // word
        -:   44:  /*
        -:   45:  if (root->isTerminal == True) {
        -:   46:    printf("ISTERMINAL PRINTING OUT WORD len(%d)\n",strlen(word));
        -:   47:    printf("%s\n",word);
        -:   48:  } */
        -:   49:
        -:   50:  dictListN(root->sibling,word,level);
        -:   51: // if (root->thisChar == 0)
        -:   52: // return; 
        -:   53:  assert(root->thisChar != '\0');
        -:   54:
        -:   55:  if (word == NULL) {
        -:   56://    word = malloc(sizeof(char)*2);
        -:   57:    word = malloc(sizeof(char)*82);
        -:   58:    assert(word != NULL);
        -:   59:    // *word = sprintf("%c\0",root->thisChar);
        -:   60:    word[0] = root->thisChar;
        -:   61:    // printf(">%c<",root->thisChar);
        -:   62:    word[1] = 0;
        -:   63:  } else {
        -:   64:    int i = level + 2; // the array size is strlen(word)+1
        -:   65://    word = realloc (word, sizeof(char)*(i));
        -:   66:    word[i-1] = 0;
        -:   67:    word[i-2] = root->thisChar;
        -:   68://    printf("ATTEMPTING TO REALLOC for >%c<",root->thisChar);
        -:   69:    // add the char to the end of word, and/or move the pointer:)
        -:   70:    // printf("%d vs %d\n",i,strlen(word));
        -:   71:  }
        -:   72:  if (root->isTerminal == True) {
        -:   73:    printf("ISTERMINAL PRINTING OUT WORD len(%d)\n",strlen(word));
        -:   74:    printf("%s\n",word);
        -:   75:  }
        -:   76:  dictListN(root->child,word,level+1);
        -:   77:}
        -:   78:#endif
        -:   79:/* begining of true functions */
        -:   80:
        -:   81:// insert into slist and return the head
        -:   82:struct wlnode* 
        -:   83:wlIns(struct wlnode* head,char* word);
        -:   84:
        -:   85:// oop, typo :)
        -:   86:struct wlnode*
        -:   87:distCompletions (struct dictionary* dict,char* word);
        -:   88:void
        -:   89:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:   90:  int level, struct wlnode* head);
        -:   91:
        -:   92:// converts all the items in a dictionary into a linked list of words
        -:   93:// this isn't that bad
        -:   94:void
      118:   95:dictToWlNew (struct dictEdge* root,char *store,
        -:   96:  int level, struct wlnode* head) {
      118:   97:  if (root == NULL) 
       60:   98:    return;// terminating case :)
       58:   99:  assert(store != NULL); // store should be defined already
       58:  100:  int i = level + 2; 
       58:  101:  store[i-1] = 0;
       58:  102:  store[i-2] = root->thisChar;
       58:  103:  if (root->isTerminal == True) {
       20:  104:    char *str = malloc(sizeof(char)*(level + 2)); 
        -:  105:    // space for new char + null
       20:  106:    assert(str != NULL); // we have enough memory
       20:  107:    strcpy(str,store); // copy everything
       20:  108:    wlIns(head,str);
        -:  109:  } // do it in order :)
       58:  110:  dictToWlNew (root->child,store,level+1,head);
       58:  111:  dictToWlNew (root->sibling,store,level,head);
        -:  112:}
        -:  113:
        -:  114:struct wlnode*
        2:  115:distCompletions (struct dictionary* dict,char* word) {
        -:  116://  printf("strlen of word is %d\n",strlen(word));return;
        2:  117:  struct wlnode* a = wlIns(NULL,"hi");
        -:  118:  char store[82];
        2:  119:  store[0] = 0; // do I need this?
        -:  120:  // this is stupid
        2:  121:  if (word[0] == 0) { // meaning that the word is blank
        -:  122:    // printf("doing old routine");
        2:  123:    dictToWlNew(dict->root,store,0,a);
        -:  124:  //  return a->next;
        -:  125:  }
        -:  126:  else {
    #####:  127:    distCompletionsN(dict->root,word,store,0,a);
        -:  128:  }
        -:  129:  // if I want to see where the gap is between words
        2:  130:  struct wlnode* re = a->next;
        2:  131:  a->next = NULL;
        2:  132:  free(a);
        2:  133:  return re;
        -:  134:}
        -:  135:
        -:  136:void
    #####:  137:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:  138:  int level, struct wlnode* head) {
    #####:  139:  if (root == NULL) {
        -:  140:    // if the root is null we are done!
    #####:  141:    return;
        -:  142:  }
    #####:  143:  assert(store != NULL); // since I declared it before
    #####:  144:  int i = level + 2; // the array size is strlen(word)+1
    #####:  145:  store[i-1] = 0;
    #####:  146:  store[i-2] = root->thisChar; 
        -:  147:  // what this does is append root->thisChar to then end of stored string
        -:  148:  // FIX
    #####:  149:  if (root->isTerminal == True) {
    #####:  150:    if (strlen(word) - 1 == level) {
    #####:  151:      if (word[level] == root->thisChar) {
    #####:  152:        char *str = malloc(sizeof(char)*(level + 2));
    #####:  153:        assert(str != NULL);
    #####:  154:        strcpy(str,store);
    #####:  155:        head = wlIns(head,str);
        -:  156:      }
        -:  157:    }
        -:  158:  }
        -:  159:/*
        -:  160:  if (root->isTerminal == True) {
        -:  161:    if (strlen(word) - level == 1 && word[level] == root->thisChar) {
        -:  162:      printf("maybe I should add %s level: %d\n",word,level);
        -:  163:    }
        -:  164:  } */
    #####:  165:  if (root->isTerminal == True 
    #####:  166:    && (word[level] == root->thisChar || level >= strlen(word))
    #####:  167:    && (level >= strlen(word) )) { 
        -:  168:    
    #####:  169:    if (strlen(store) == 0) {
    #####:  170:      return; // since the string is empty, we don't add it
        -:  171:    }
        -:  172:    // printf("adding store %s\n",store);
        -:  173:    // printf("adding str %s %p len: %d\n",str,str,strlen(str));
    #####:  174:    char *str = malloc(sizeof(char)*(level + 2));
    #####:  175:    assert(str != NULL);
    #####:  176:    strcpy(str,store);
    #####:  177:    head = wlIns(head,str);
        -:  178:  } // just because we added a word doesn't mean we're finished!
    #####:  179:  if (level < strlen(word) && word[level] == root->thisChar) {
        -:  180:    // printf("we have a hit for %c!\n",word[level]);
    #####:  181:    distCompletionsN (root->child,word,store,level+1,head);
    #####:  182:  } else if (level >=strlen(word)) {
        -:  183:    // printf("here");
    #####:  184:    distCompletionsN (root->child,word,store,level+1,head);
        -:  185:    // since I add child first, it is in ORDER :)
    #####:  186:    distCompletionsN (root->sibling,word,store,level,head);
        -:  187:  } else {
    #####:  188:    distCompletionsN (root->sibling,word,store,level,head);
        -:  189:  } 
        -:  190:  /* these three cases
        -:  191:
        -:  192:  */
        -:  193:}
        -:  194:// just to test out a few algorithms.
        -:  195:struct wlnode* 
        -:  196:wlIns(struct wlnode* head,char* word);
        -:  197:void 
        -:  198:insertWordR (struct dictEdge * node, char* word);
        -:  199:bool
        -:  200:dictLookupN (struct dictEdge* node,char* word) ;
        -:  201:void
        -:  202:edgeFree(struct dictEdge *node);
        -:  203:struct dictEdge* dictEdgeNew(char thisChar);
        -:  204:void 
        -:  205:printDict(struct dictionary *dict);
        -:  206:
        -:  207:/* Initialise the dictionary structure
        -:  208: */
        -:  209:struct dictionary*
        2:  210:dictInit () {
        -:  211:  // we create a new dictionary and then we return it
        2:  212:  struct dictionary* ndict = malloc(sizeof(struct dictionary));
        2:  213:  assert(ndict != NULL); 
        2:  214:  ndict->root = NULL;
        2:  215:  return ndict;
        -:  216:}
        -:  217:
        -:  218:struct dictEdge* 
       58:  219:dictEdgeNew(char thisChar) {
       58:  220:  struct dictEdge *ndictEdge = malloc(sizeof(struct dictEdge));
       58:  221:  assert(ndictEdge != NULL);
       58:  222:  ndictEdge->thisChar = thisChar;
       58:  223:  ndictEdge->child = NULL;
       58:  224:  ndictEdge->sibling = NULL;
       58:  225:  ndictEdge->isTerminal = 0;
       58:  226:  return ndictEdge;
        -:  227:}
        -:  228:    
    #####:  229:void printEdge(struct dictEdge* dnode, long n) {
    #####:  230:  if (dnode == NULL) {
    #####:  231:    return;
        -:  232:  }
        -:  233:  int i;
    #####:  234:  for (i=0;i != n;++i)
    #####:  235:    printf("  ");
        -:  236:  
    #####:  237:  if (dnode->isTerminal == True) {
    #####:  238:    printf("\033[1;33m%c\033[m\n",dnode->thisChar);
        -:  239:  } else {
    #####:  240:    printf("%c\n",dnode->thisChar);
        -:  241:
        -:  242:  }
    #####:  243:  printEdge(dnode->child, n+1); 
    #####:  244:  printEdge(dnode->sibling,n);
        -:  245:}
        -:  246:
        -:  247:/* Insert a single word into the dictionary 
        -:  248: */
        -:  249:void
       20:  250:dictInsertWord (struct dictionary* dict, char* word) {
        -:  251:  // assume I'm not in the list.
       20:  252:  if (dict->root == NULL) {
        2:  253:    dict->root = dictEdgeNew(word[0]);
        -:  254:  }
        -:  255:// todo this code still seems bugged like fuck
        -:  256:  // oh my this is icky
        -:  257:  // well, I suppose it's required though
       20:  258:  if (dict->root->thisChar > word[0]) {
        1:  259:    perr("noes :( fixing node");
        1:  260:    struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  261:    newp->sibling = dict->root;
        1:  262:    dict->root = newp;
        -:  263:  } // TODO, make sure this won't leave any extra nodes
        -:  264://  printf("comparing %d with %d\n",dict->root->thisChar,word[0]);
       20:  265:  assert(dict->root->thisChar <= word[0]); // make sure that the root is okay :)
       20:  266:  insertWordR (dict->root, word); 
       20:  267:}
        -:  268:
        -:  269:
        -:  270:// the amount of time this takes is dependant both on size of word and size of trie
        -:  271:
        -:  272:void 
       80:  273:insertWordR (struct dictEdge * node, char* word) {
       80:  274:  assert(node != NULL);
        -:  275:  // oh I remember again, to prevent against sloppy code ;)
        -:  276:  // passing a null edge is silly
        -:  277:
        -:  278:  /*
        -:  279:  if (word[1] == 0) {
        -:  280:    node->isTerminal = True;
        -:  281:  } */
        -:  282:  // FIX
        -:  283:  // Forgot about insert in order
        -:  284:  /*
        -:  285:  if (word[0] == 0) {
        -:  286:    // terminating
        -:  287:    printf("a triggering\n");
        -:  288:    node->isTerminal = True;
        -:  289:    return;
        -:  290:  }
        -:  291:  */
        -:  292:  // I do believe that kitten's algorithm was a lot better
        -:  293:  //printf("input string-> %s\n",word);
        -:  294:  //char first = word[0];
       80:  295:  bool found = False;
       80:  296:  struct dictEdge* roverPapa = NULL;
        -:  297:  //stopping case, word[0] == \0 // this is a lie!
        -:  298:
       80:  299:  if (word[0] != '\0') {
       80:  300:    struct dictEdge* rover = node;
        -:  301:  
       80:  302:    if (node->thisChar > word[0]) {
    #####:  303:      perr("we have a fucking problem");
    #####:  304:      assert(1 == 0);
        -:  305:    }
        -:  306:
      262:  307:    while (rover != NULL && !found) {
        -:  308:      // we search until we find a match or not
        -:  309:// new
      105:  310:      if (rover->thisChar > word[0]) {
        -:  311:        // ie it's not in the list, since we assume it's ordered
        -:  312:
        -:  313:        // insert it in order
        3:  314:        assert(roverPapa != NULL);
        3:  315:        struct dictEdge* newp = dictEdgeNew(word[0]);
        3:  316:        roverPapa->sibling = newp;
        3:  317:        newp->sibling = rover;
        -:  318:        
        -:  319:        // recurse.
        3:  320:        if (word[1] == 0) {
        1:  321:          newp->isTerminal = True;
        -:  322:        } else {       
        2:  323:          struct dictEdge* newcp = dictEdgeNew(word[1]);
        2:  324:          newp->child = newcp;
        2:  325:          insertWordR(newcp,&word[1]);
        -:  326:        }
        3:  327:        return;
        -:  328:
        -:  329:      }
      102:  330:      if (rover->thisChar == word[0]) {
       71:  331:        found = True;
        -:  332:        // printf("FOUND YAY");
        -:  333:      } else {
       31:  334:        roverPapa = rover;
       31:  335:        rover = rover->sibling;
        -:  336:      }
        -:  337:    }
        -:  338:    // we add it to the end ;)
       77:  339:    if (found == False) { // not found :) && not placed in order
        6:  340:      fprintf(stderr,"not found with arg %s\n",word);
        -:  341:      // just add the whole word in.
        6:  342:      rover = node; 
       16:  343:      while (rover->sibling != NULL) {
        4:  344:        rover = rover->sibling;
        -:  345:      }
        6:  346:      rover->sibling = dictEdgeNew(word[0]);
        6:  347:      node = rover->sibling;
        -:  348:
        6:  349:      int i = 1;
       27:  350:      while (word[i] != 0) {
       15:  351:        struct dictEdge* rover = node;
        -:  352:        int j;
        -:  353:        // terrible code
        -:  354:        // TODO
       38:  355:        for (j=0;j<i-1;j++) {
       23:  356:          assert(rover->child != NULL);
       23:  357:          rover = rover->child;
        -:  358:        }
       15:  359:        rover->child = dictEdgeNew(word[i]);      
        -:  360:     //  printf("new child pointing to %p\n",rover->child);
       15:  361:         ++i;
       15:  362:         if (word[i] == '\0') {
        5:  363:           rover->child->isTerminal = True;
        -:  364:         }
        -:  365:       }
        6:  366:       if (i == 1) { // bug fix.
        -:  367:       // we didn't enter loop
        -:  368:       // then the node is the final element
        1:  369:         node->isTerminal = True;
        -:  370:       } // seems to make sense to put this at the front :) 
        -:  371:       // case for notentering the loop
        -:  372:     }
        -:  373:     else { 
        -:  374:      // found == True
        -:  375:      // looks like a bug here;
       71:  376:      if (rover->child != NULL) {
       35:  377:        if (word[1] == '\0') { 
        4:  378:           printf("HERE"); // tc3 goes here
        4:  379:           rover->isTerminal = True; 
        -:  380:        }
        -:  381:        else {
        -:  382:          // new FIX
        -:  383:          // inorderFix, create the node and set the pointer
       31:  384:          if (rover->child->thisChar > word[1]) {
        -:  385:            // we need to create
        2:  386:            struct dictEdge* newp = dictEdgeNew(word[1]);
        2:  387:            newp->sibling = rover->child;
        2:  388:            rover->child = newp;
        -:  389:          }
       31:  390:          insertWordR(rover->child,&word[1]); 
        -:  391:        }
        -:  392:      }
        -:  393:      else {
        -:  394:        //printf("->>%s\n",word);
       36:  395:        if (word[1] == '\0') { 
        9:  396:           rover->isTerminal = True;
        -:  397:        }
        -:  398:        else {
       27:  399:           rover->child = dictEdgeNew(word[1]);
       27:  400:           insertWordR(rover->child,&word[1]);
        -:  401:           // this could be done with a forloop
        -:  402:           // since all we're doing is spawning children
        -:  403:        }
        -:  404:      }
        -:  405:    }
        -:  406:  }
        -:  407:}
        -:  408:
        -:  409:/* Insert a list of words into the dictionary 
        -:  410: */
        -:  411:void
    #####:  412:dictInsertWords (struct dictionary* dict, struct wlnode* words) {
        -:  413:  // FIX
    #####:  414:  while (words != NULL) {
    #####:  415:    dictInsertWord(dict,words->word);
    #####:  416:    words = words->next;
        -:  417:  }
    #####:  418:}
        -:  419:
        -:  420:/* Check whether a given word is in the dictionary
        -:  421: */
        -:  422:bool
       17:  423:dictLookup (struct dictionary* dict, char* word) {
        -:  424:  // is there a more efficient way.
        -:  425:  // by using two loops, this can be implemented
        -:  426:  // thanks to Ian Craig who showed me :)
       17:  427:  assert(dict != NULL);
       17:  428:  return dictLookupN(dict->root,word);
        -:  429:}
        -:  430:
        -:  431:// n for internal? new?
        -:  432:bool
       60:  433:dictLookupN (struct dictEdge* node,char* word) {
        -:  434:  // todo this code still seems bugged like fuck
        -:  435:  // terminating case. // dictionary/word is NULL/\0
       60:  436:  if (node == NULL) {
        -:  437:    // very special case, dictionary is empty, clearly not in dictionary
    #####:  438:    return False;
        -:  439:  }
       60:  440:  if (word[0] == 0) { // shouldn't really go in here... 
    #####:  441:    return False;
        -:  442:  }
        -:  443:
       60:  444:  if (word[1] == '\0') {  // if it's the last letter
        9:  445:      struct dictEdge *rover = node;
        -:  446:      //printf("searching for %c %c\n",word[0],rover->thisChar);
        -:  447:      // while (word[0] < rover->thisChar && rover->sibling != NULL) 
        -:  448:      // while (rover->sibling != NULL && word[0] < rover->thisChar) // damn I had this, it's broken so badly 
       20:  449:      while (rover->sibling != NULL && word[0] > rover->thisChar) 
        -:  450:      {
        -:  451:        // and then it took me a while to figure why it's rover->sibling not rover
        -:  452:        // wow, terrible coding, I didn't even think of the first 
        -:  453:        // check
        -:  454:        //printf("PASS\n");
        2:  455:        rover = rover->sibling;
        -:  456:      }
        9:  457:      if (word[0] == rover->thisChar && rover->isTerminal == True) {
        4:  458:        return True;
        -:  459:      }
        -:  460:      // bugged here
        5:  461:      return False;
        -:  462:  }
       51:  463:  struct dictEdge *rover = node;
      148:  464:  while (rover != NULL) { 
       90:  465:    if (word[0] == rover->thisChar) {
        -:  466:      // if we are here we know that word[1] != 0
        -:  467:      // therefore we have not finished
        -:  468:      // rover child could be null
       44:  469:      if (rover->child == NULL) {
        1:  470:        return False; // no more children, therefore it can't be found
        -:  471:      }
       43:  472:      return dictLookupN(rover->child,&word[1]);
        -:  473:    } else {
       46:  474:      rover = rover->sibling;
        -:  475:    }
        -:  476:  }
        -:  477:  // if it gets here it means no matches in the siblings
        7:  478:  return False;
        -:  479:}
        -:  480:
        -:  481:bool
       17:  482:dictLookupIter (struct dictionary* dict, char* word) {
       17:  483:  int i = 0; // loop through elements of the word
       17:  484:  struct dictEdge* node = dict->root;
        -:  485:  struct dictEdge* rover;
       82:  486:  while (i != strlen(word)) {
      160:  487:    for (rover = node;
        -:  488:      rover != NULL;
       38:  489:      rover = rover->sibling) {
        -:  490:      // if equal
       98:  491:      if (word[i] == rover->thisChar) {
       51:  492:        if (word[i + 1] == 0) {
        7:  493:          if (rover->isTerminal) {
        4:  494:            return True;
        -:  495:          }
        -:  496:        }
       47:  497:        node = rover->child;
       47:  498:        break; // break out of loop
        -:  499:      }
        -:  500:      // if we've reached the end of the word and we haven't found it then
       47:  501:      if (rover->sibling == NULL || word[i] < rover->thisChar) {
        -:  502:        // don't really need the second one
        9:  503:        return False;
        -:  504:      }
        -:  505:    }
       48:  506:    ++i; // look up the next letter with parent node
        -:  507:  }
        4:  508:  return False;
        -:  509:}
        -:  510:
        -:  511:/* Extract all words in the dictionary (the order does not matter).
        -:  512: * Should return them in alphabetical order
        -:  513: * Complexity: see constraint in the assignment specification.
        -:  514: */
        -:  515:struct wlnode*
        2:  516:dictCompletions (struct dictionary* dict, char* word) {
        2:  517:  return wlRev(distCompletions(dict,word)); // fun fix
        -:  518:  return distCompletions(dict,word);
        -:  519:}
        -:  520:
        -:  521:/* testing functions for the above */
        -:  522:void
    #####:  523:printwl (struct wlnode* wl) {
        -:  524:   struct wlnode * cur;
    #####:  525:   for (cur = wl; NULL != cur; cur =  cur->next)
    #####:  526:      fprintf (stdout, "%s\n", cur->word);
        -:  527:#if 0
        -:  528:  /*
        -:  529:   struct wlnode * cur;
        -:  530:   for (cur = wl; NULL != cur; cur =  cur->next)
        -:  531:      fprintf (stdout, "%s\n", cur->word);
        -:  532:      */
        -:  533:   struct wlnode * cur;
        -:  534:   cur = wl;
        -:  535:   //while (cur != NULL && cur != 0x65646e61) {
        -:  536:   while (cur != NULL) { 
        -:  537:       cur = cur->next;
        -:  538:       printf("cur %p\n",cur);
        -:  539:   }
        -:  540:   //return;
        -:  541:   //for (cur = wl; NULL != cur && cur != 0x65646e61; cur = cur->next)
        -:  542:   for (cur = wl; NULL != cur; cur = cur->next)
        -:  543:     fprintf (stdout, "%s %p\n", cur->word, cur->word);
        -:  544:#endif
    #####:  545:}
        -:  546:
        -:  547:
        -:  548:/* Erase all dictionary entries and release all memory allocated for the
        -:  549: * dictionary.
        -:  550: */
        -:  551:// Complexity O(n) // linearly dependant on size of trie
        -:  552:void
        2:  553:dictFree (struct dictionary* dict) {
        -:  554:  // the plan, free all the nodes then free the dictionary :)
        2:  555:  edgeFree(dict->root);
        2:  556:  free(dict); // freeing the dictionary is easy
        2:  557:}
        -:  558:
        -:  559:// internal call
        -:  560:// recursively free all the nodes
        -:  561:// Complexity O(n) // linearly dependant on size of trie
        -:  562:void
      118:  563:edgeFree(struct dictEdge *node) {
      118:  564:  if (node != NULL) {   
       58:  565:    edgeFree(node->sibling);
       58:  566:    edgeFree(node->child);
       58:  567:    node->sibling = NULL;
       58:  568:    node->child = NULL;
       58:  569:    free(node);
        -:  570:  }
      118:  571:}
        -:  572:
        -:  573:/* Return the root of the trie (i.e. dictionary). 
        -:  574: * If the dictionary is empty, then return NULL. 
        -:  575: * Otherwise, return the root of the trie. 
        -:  576: */ // complexity O(1)
        -:  577:struct dictEdge*
    #####:  578:dictGetRoot (struct dictionary* dict) { 
    #####:  579:  return dict->root;
        -:  580:}
        -:  581:
        -:  582:// word list functions below :)
        -:  583:/*
        -:  584:struct wlnode* 
        -:  585:wlIns (struct wlnode* wl, char* word) {
        -:  586:  struct wlnode* new = malloc(sizeof(struct wlnode));
        -:  587:  // something about this routine looks strange to me :$
        -:  588:  assert(new != NULL);
        -:  589:  new->word = word;
        -:  590:  new->next = NULL;
        -:  591:  if (wl == NULL) {
        -:  592:    wl = new;
        -:  593:  }
        -:  594:  else {
        -:  595:    struct wlnode* rover = wl; // coming back to this, I
        -:  596:    // was just thinking, what the heck am I doing here ;D
        -:  597:    // since there was no requirement for it to be ordered
        -:  598:    while (rover->next != NULL) {
        -:  599:      rover = rover->next;
        -:  600:    }
        -:  601:    rover->next = new;
        -:  602:  }
        -:  603:  return wl;
        -:  604:}*/
        -:  605:
        -:  606:/* This function does NOT do what it says on the tin */
        -:  607:// due to the fact that the initial complexity was O(n)
        -:  608:// Complexity, O(1)
        -:  609:// I was thinking of moving the mallocing to this function but then thought
        -:  610:// I might break something
        -:  611:/* This function inserts a word by reference in the second position, (or first if wlnode is NULL */
        -:  612:struct wlnode* 
       43:  613:wlIns (struct wlnode* wl, char* word) {
       43:  614:  struct wlnode* new = malloc(sizeof(struct wlnode));
       43:  615:  assert(new != NULL);
        -:  616:  // since we store the first node with dictCompletion
       43:  617:  new->word = word;
       43:  618:  if (wl == NULL) {
        7:  619:    new->next = wl;
        7:  620:    wl = new;
        -:  621:  }
        -:  622:  else {
       36:  623:    new->next = wl->next;
       36:  624:    wl->next = new;
        -:  625:  }
       43:  626:  return wl;
        -:  627:}
        -:  628:// Operation Complexity O(n)
        -:  629:// Space Requirement, O(1)
        -:  630:// In place reversing of a linked list
        4:  631:struct wlnode* wlRev(struct wlnode* wl) {
        -:  632:  // done in lab 1
        4:  633:  struct wlnode* new = wlIns(NULL,"");
        4:  634:  struct wlnode* rover = wl;
       45:  635:  while (rover != NULL) {
       37:  636:    struct wlnode* store = rover->next; 
        -:  637:      // do I get better performance if I store this variable outside the loop?
       37:  638:    rover->next = new->next;
       37:  639:    new->next = rover;
       37:  640:    rover = store; 
        -:  641:  }
        4:  642:  rover = new->next; // saves defining another variable :)
        4:  643:  new->next = NULL;
        4:  644:  free(new);
        4:  645:  return rover;
        -:  646:}
        -:  647:
        -:  648://unused
        -:  649:// Complexity O(n)
        -:  650:void
    #####:  651:wlfree (struct wlnode* wl) {
    #####:  652:  if (wl == NULL) {
    #####:  653:    return;
        -:  654:  }
    #####:  655:  wlfree(wl->next);
    #####:  656:  free(wl);
        -:  657:}
