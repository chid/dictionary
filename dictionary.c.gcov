        -:    0:Source:dictionary.c
        -:    0:Graph:dictionary.gcno
        -:    0:Data:dictionary.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "dictionary.h"
        -:    5:#include <string.h>
        -:    6:
        -:    7:/* xkcd.com/844 describes this code perfectly */
        -:    8:/*
        -:    9:  the way I should have coded this was write two functions
        -:   10:
        -:   11:  lookupAndReturnNode (struct dictionary *dict, char *word)
        -:   12:    which returns the final node that could be found
        -:   13:    and also the levels it has traversed (no of times it called node->child)
        -:   14:
        -:   15:  generateWl (dictEdge *node, char* prefix)
        -:   16:    which returns a wordlist of all words under node
        -:   17:    and prepending the prefix
        -:   18:
        -:   19:  after these two functions are written, all other functions can be called just by using these two
        -:   20:
        -:   21:  lookup
        -:   22:    lookupAndReturnNode
        -:   23:    if (strlen(word) == i + 1) // i indexed from 0
        -:   24:      return True
        -:   25:    return False
        -:   26:  dictCompletions
        -:   27:    lookupAndReturnNode
        -:   28:    word[i+1] = 0
        -:   29:    generateWl (node, word);
        -:   30:  printdict
        -:   31:    generateWl (node, "")
        -:   32:    printwl (wl)
        -:   33:  insert
        -:   34:    lookupAndReturnNode
        -:   35:    while (i < strlen(word))
        -:   36:      node->child = dictEdgeNew(word[i + 1])
        -:   37:      node = node->child
        -:   38:      ++i
        -:   39:
        -:   40:  should've written it all iteratively
        -:   41:*/
        -:   42:
        -:   43:struct wlnode* wlRev(struct wlnode*);
        -:   44:void 
        1:   45:perr(char error[]) {
        -:   46:#define DEBUGP
        -:   47:#ifdef DEBUGP
        1:   48:  fprintf(stderr,"%s\n",error);
        -:   49:#endif
        1:   50:}
        -:   51:
        -:   52:/* 
        -:   53:  unused functions
        -:   54:  used as a basis for the final functions :)
        -:   55:    */
        -:   56:
        -:   57:void printEdge(struct dictEdge* dnode, long n);
    #####:   58:void printDict(struct dictionary* dict) {
    #####:   59:  printEdge(dict->root,0);
    #####:   60:}
        -:   61:/* begining of true functions */
        -:   62:
        -:   63:// insert into slist and return the head
        -:   64:struct wlnode* 
        -:   65:wlIns(struct wlnode* head,char* word);
        -:   66:
        -:   67:// oops, typo :)
        -:   68:struct wlnode*
        -:   69:distCompletions (struct dictionary* dict,char* word);
        -:   70:void
        -:   71:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:   72:  int level, struct wlnode* head);
        -:   73:
        -:   74:// converts all the items in a dictionary into a linked list of words
        -:   75:// this isn't that bad
        -:   76:void
       71:   77:dictToWlNew (struct dictEdge* root,char *store,
        -:   78:  int level, struct wlnode* head) {
       71:   79:  if (root == NULL) 
       36:   80:    return;// terminating case :)
       35:   81:  assert(store != NULL); // store should be defined already
       35:   82:  int i = level + 2; 
        -:   83:  // space for new char + null
       35:   84:  store[i-1] = 0;
       35:   85:  store[i-2] = root->thisChar;
       35:   86:  if (root->isTerminal == True) {
        9:   87:    char *str = malloc(sizeof(char)*(level + 2)); 
        9:   88:    assert(str != NULL); // we have enough memory
        9:   89:    strcpy(str,store); // copy everything
        9:   90:    wlIns(head,str);
        -:   91:  } // do it in order :)
       35:   92:  dictToWlNew (root->child,store,level+1,head);
       35:   93:  dictToWlNew (root->sibling,store,level,head);
        -:   94:}
        -:   95:
        -:   96:// Sorry about that, it's a bit dodgy the ordering
        -:   97:struct wlnode*
        1:   98:distCompletions (struct dictionary* dict,char* word) {
        1:   99:  struct wlnode* a = wlIns(NULL,"");
        -:  100:  char store[82];
        1:  101:  store[0] = 0; // do I need this? // this is stupid
        1:  102:  if (word[0] == 0) { // meaning that the word is blank
        1:  103:    dictToWlNew(dict->root,store,0,a);
        -:  104:  }
        -:  105:  else {
    #####:  106:    distCompletionsN(dict->root,word,store,0,a);
        -:  107:  }
        1:  108:  struct wlnode* re = a->next;
        1:  109:  a->next = NULL;
        1:  110:  free(a);
        1:  111:  return re;
        -:  112:}
        -:  113:
        -:  114:void
    #####:  115:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:  116:  int level, struct wlnode* head) {
    #####:  117:  if (root == NULL) {
    #####:  118:    return; // if the root is null we are done!
        -:  119:  }
    #####:  120:  assert(store != NULL); // since I declared it before
    #####:  121:  int i = level + 2; // the array size is strlen(word)+1
    #####:  122:  store[i-1] = 0;
    #####:  123:  store[i-2] = root->thisChar; 
        -:  124:  // what this does is append root->thisChar to then end of stored string
        -:  125:  // FIX
        -:  126:
    #####:  127:  if (root->isTerminal == True) {
    #####:  128:    if (strlen(word) - 1 == level) {
    #####:  129:      if (word[level] == root->thisChar) {
    #####:  130:        char *str = malloc(sizeof(char)*(level + 2));
    #####:  131:        assert(str != NULL);
    #####:  132:        strcpy(str,store);
    #####:  133:        head = wlIns(head,str);
        -:  134:      }
        -:  135:    }
        -:  136:  }
        -:  137:
    #####:  138:  if (root->isTerminal == True // signifying end of word
    #####:  139:    && (word[level] == root->thisChar || level >= strlen(word)) 
    #####:  140:    && (level >= strlen(word) )) { 
        -:  141:    
    #####:  142:    if (strlen(store) == 0) {
    #####:  143:      return; // since the string is empty, we don't add it
        -:  144:    }
    #####:  145:    char *str = malloc(sizeof(char)*(level + 2));
    #####:  146:    assert(str != NULL);
    #####:  147:    strcpy(str,store);
    #####:  148:    head = wlIns(head,str);
        -:  149:  } // just because we added a word doesn't mean we're finished!
        -:  150:
    #####:  151:  if (level < strlen(word) && word[level] == root->thisChar) {
        -:  152:    // case what we're looking for is directly below
        -:  153:    
    #####:  154:    distCompletionsN (root->child,word,store,level+1,head);
    #####:  155:  } else if (level >=strlen(word)) {
        -:  156:    // if we've already 'made it' past checking the word
        -:  157:    // level is 0 indexed, strlen starts at 1 (so to speak)
        -:  158:    // hence the equality
    #####:  159:    distCompletionsN (root->child,word,store,level+1,head);
        -:  160:    // since I add child first, it is in ORDER :)
    #####:  161:    distCompletionsN (root->sibling,word,store,level,head);
        -:  162:  } else {
        -:  163:    // go onto the next sibling then
    #####:  164:    distCompletionsN (root->sibling,word,store,level,head);
        -:  165:  } 
        -:  166:  /* these three cases
        -:  167:
        -:  168:  */
        -:  169:}
        -:  170:// just to test out a few algorithms.
        -:  171:struct wlnode* 
        -:  172:wlIns(struct wlnode* head,char* word);
        -:  173:void 
        -:  174:insertWordR (struct dictEdge * node, char* word);
        -:  175:bool
        -:  176:dictLookupN (struct dictEdge* node,char* word) ;
        -:  177:void
        -:  178:edgeFree(struct dictEdge *node);
        -:  179:struct dictEdge* dictEdgeNew(char thisChar);
        -:  180:void 
        -:  181:printDict(struct dictionary *dict);
        -:  182:
        -:  183:/* Initialise the dictionary structure
        -:  184: */
        -:  185:struct dictionary*
        1:  186:dictInit () {
        -:  187:  // we create a new dictionary and then we return it
        1:  188:  struct dictionary* ndict = malloc(sizeof(struct dictionary));
        1:  189:  assert(ndict != NULL); 
        1:  190:  ndict->root = NULL;
        1:  191:  return ndict;
        -:  192:}
        -:  193:
        -:  194:struct dictEdge* 
       35:  195:dictEdgeNew(char thisChar) {
       35:  196:  struct dictEdge *ndictEdge = malloc(sizeof(struct dictEdge));
       35:  197:  assert(ndictEdge != NULL);
       35:  198:  ndictEdge->thisChar = thisChar;
       35:  199:  ndictEdge->child = NULL;
       35:  200:  ndictEdge->sibling = NULL;
       35:  201:  ndictEdge->isTerminal = 0;
       35:  202:  return ndictEdge;
        -:  203:}
        -:  204:    
    #####:  205:void printEdge(struct dictEdge* dnode, long n) {
    #####:  206:  if (dnode == NULL) {
    #####:  207:    return;
        -:  208:  }
        -:  209:  int i;
    #####:  210:  for (i=0;i != n;++i)
    #####:  211:    printf("  ");
        -:  212:  
    #####:  213:  if (dnode->isTerminal == True) {
    #####:  214:    printf("\033[1;33m%c\033[m\n",dnode->thisChar);
        -:  215:  } else {
    #####:  216:    printf("%c\n",dnode->thisChar);
        -:  217:
        -:  218:  }
    #####:  219:  printEdge(dnode->child, n+1); 
    #####:  220:  printEdge(dnode->sibling,n);
        -:  221:}
        -:  222:
        -:  223:/* Insert a single word into the dictionary 
        -:  224: */
        -:  225:void
        9:  226:dictInsertWord (struct dictionary* dict, char* word) {
        -:  227:  // assume I'm not in the list.
        9:  228:  if (dict->root == NULL) {
        1:  229:    dict->root = dictEdgeNew(word[0]);
        -:  230:  }
        -:  231:// todo this code still seems bugged like fuck
        -:  232:  // oh my this is icky
        -:  233:  // well, I suppose it's required though
        9:  234:  if (dict->root->thisChar > word[0]) {
        1:  235:    perr("noes :( fixing node");
        1:  236:    struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  237:    newp->sibling = dict->root;
        1:  238:    dict->root = newp;
        -:  239:  } // TODO, make sure this won't leave any extra nodes
        -:  240://  printf("comparing %d with %d\n",dict->root->thisChar,word[0]);
        9:  241:  assert(dict->root->thisChar <= word[0]); // make sure that the root is okay :)
        9:  242:  insertWordR (dict->root, word); 
        9:  243:}
        -:  244:
        -:  245:
        -:  246:// the amount of time this takes is dependant both on size of word and size of trie
        -:  247:
        -:  248:void 
       29:  249:insertWordR (struct dictEdge * node, char* word) {
       29:  250:  assert(node != NULL);
        -:  251:  // oh I remember again, to prevent against sloppy code ;)
        -:  252:  // passing a null edge is silly
        -:  253:
        -:  254:  // FIX
        -:  255:  // Forgot about insert in order
        -:  256:  
        -:  257:  // I do believe that kitten's algorithm was a lot better
        -:  258:  
       29:  259:  bool found = False; // since I need to break out two levels
       29:  260:  struct dictEdge* roverPapa = NULL;
        -:  261:  //stopping case, word[0] == \0 // this is a lie!
        -:  262:
       29:  263:  if (word[0] != '\0') {
       29:  264:    struct dictEdge* rover = node;
        -:  265:  
       29:  266:    if (node->thisChar > word[0]) {
    #####:  267:      perr("we have a fucking problem");
    #####:  268:      assert(1 == 0);
        -:  269:    }
        -:  270:
       99:  271:    while (rover != NULL && !found) {
        -:  272:      // we search until we find a match or not
        -:  273:// new
       42:  274:      if (rover->thisChar > word[0]) {
        -:  275:        // ie it's not in the list, since we assume it's ordered
        -:  276:
        -:  277:        // insert it in order
        1:  278:        assert(roverPapa != NULL);
        1:  279:        struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  280:        roverPapa->sibling = newp;
        1:  281:        newp->sibling = rover;
        -:  282:        
        -:  283:        // recurse.
        1:  284:        if (word[1] == 0) {
    #####:  285:          newp->isTerminal = True;
        -:  286:        } else {       
        1:  287:          struct dictEdge* newcp = dictEdgeNew(word[1]);
        1:  288:          newp->child = newcp;
        1:  289:          insertWordR(newcp,&word[1]);
        -:  290:        }
        1:  291:        return;
        -:  292:
        -:  293:      }
       41:  294:      if (rover->thisChar == word[0]) {
       24:  295:        found = True;
        -:  296:        // printf("FOUND YAY");
        -:  297:      } else {
       17:  298:        roverPapa = rover;
       17:  299:        rover = rover->sibling;
        -:  300:      }
        -:  301:    }
        -:  302:    // we add it to the end ;)
       28:  303:    if (found == False) { // not found :) && not placed in order
        4:  304:      fprintf(stderr,"not found with arg %s\n",word);
        -:  305:      // just add the whole word in.
        4:  306:      rover = node; 
       11:  307:      while (rover->sibling != NULL) {
        3:  308:        rover = rover->sibling;
        -:  309:      }
        4:  310:      rover->sibling = dictEdgeNew(word[0]);
        4:  311:      node = rover->sibling;
        -:  312:
        4:  313:      int i = 1;
       21:  314:      while (word[i] != 0) {
       13:  315:        struct dictEdge* rover = node;
        -:  316:        int j;
        -:  317:        // terrible code
        -:  318:        // TODO
       35:  319:        for (j=0;j<i-1;j++) {
       22:  320:          assert(rover->child != NULL);
       22:  321:          rover = rover->child;
        -:  322:        }
       13:  323:        rover->child = dictEdgeNew(word[i]);      
        -:  324:     //  printf("new child pointing to %p\n",rover->child);
       13:  325:         ++i;
       13:  326:         if (word[i] == '\0') {
        4:  327:           rover->child->isTerminal = True;
        -:  328:         }
        -:  329:       }
        4:  330:       if (i == 1) { // bug fix.
        -:  331:       // we didn't enter loop
        -:  332:       // then the node is the final element
    #####:  333:         node->isTerminal = True;
        -:  334:       } // seems to make sense to put this at the front :) 
        -:  335:       // case for notentering the loop
        -:  336:     }
        -:  337:     else { 
        -:  338:      // found == True
        -:  339:      // looks like a bug here;
       24:  340:      if (rover->child != NULL) {
        7:  341:        if (word[1] == '\0') { 
    #####:  342:           printf("HERE"); // tc3 goes here
    #####:  343:           rover->isTerminal = True; 
        -:  344:        }
        -:  345:        else {
        -:  346:          // new FIX
        -:  347:          // inorderFix, create the node and set the pointer
        7:  348:          if (rover->child->thisChar > word[1]) {
        -:  349:            // we need to create
        2:  350:            struct dictEdge* newp = dictEdgeNew(word[1]);
        2:  351:            newp->sibling = rover->child;
        2:  352:            rover->child = newp;
        -:  353:          }
        7:  354:          insertWordR(rover->child,&word[1]); 
        -:  355:        }
        -:  356:      }
        -:  357:      else {
        -:  358:        //printf("->>%s\n",word);
       17:  359:        if (word[1] == '\0') { 
        5:  360:           rover->isTerminal = True;
        -:  361:        }
        -:  362:        else {
       12:  363:           rover->child = dictEdgeNew(word[1]);
       12:  364:           insertWordR(rover->child,&word[1]);
        -:  365:           // this could be done with a forloop
        -:  366:           // since all we're doing is spawning children
        -:  367:        }
        -:  368:      }
        -:  369:    }
        -:  370:  }
        -:  371:}
        -:  372:
        -:  373:/* Insert a list of words into the dictionary 
        -:  374: */
        -:  375:void
    #####:  376:dictInsertWords (struct dictionary* dict, struct wlnode* words) {
    #####:  377:  while (words != NULL) {
    #####:  378:    dictInsertWord(dict,words->word); // icky
    #####:  379:    words = words->next;
        -:  380:  }
    #####:  381:}
        -:  382:
        -:  383:/* Check whether a given word is in the dictionary
        -:  384: */
        -:  385:bool
       20:  386:dictLookup (struct dictionary* dict, char* word) {
        -:  387:  // is there a more efficient way.
        -:  388:  // by using two loops, this can be implemented
        -:  389:  // thanks to Ian Craig who showed me :)
       20:  390:  assert(dict != NULL);
       20:  391:  return dictLookupN(dict->root,word);
        -:  392:}
        -:  393:
        -:  394:// n for internal? new?
        -:  395:bool
       71:  396:dictLookupN (struct dictEdge* node,char* word) {
        -:  397:  // todo this code still seems bugged like fuck
        -:  398:  // terminating case. // dictionary/word is NULL/\0
       71:  399:  if (node == NULL) {
        -:  400:    // very special case, dictionary is empty, clearly not in dictionary
    #####:  401:    return False;
        -:  402:  }
       71:  403:  if (word[0] == 0) { // shouldn't really go in here... 
    #####:  404:    return False;
        -:  405:  }
        -:  406:
       71:  407:  if (word[1] == '\0') {  // if it's the last letter
       11:  408:      struct dictEdge *rover = node;
        -:  409:      //printf("searching for %c %c\n",word[0],rover->thisChar);
        -:  410:      // while (word[0] < rover->thisChar && rover->sibling != NULL) 
        -:  411:      // while (rover->sibling != NULL && word[0] < rover->thisChar) // damn I had this, it's broken so badly 
       24:  412:      while (rover->sibling != NULL && word[0] > rover->thisChar) 
        -:  413:      {
        -:  414:        // and then it took me a while to figure why it's rover->sibling not rover
        -:  415:        // wow, terrible coding, I didn't even think of the first 
        -:  416:        // check
        -:  417:        //printf("PASS\n");
        2:  418:        rover = rover->sibling;
        -:  419:      }
       11:  420:      if (word[0] == rover->thisChar && rover->isTerminal == True) {
        5:  421:        return True;
        -:  422:      }
        -:  423:      // bugged here
        6:  424:      return False;
        -:  425:  }
       60:  426:  struct dictEdge *rover = node;
      173:  427:  while (rover != NULL) { 
      106:  428:    if (word[0] == rover->thisChar) {
        -:  429:      // if we are here we know that word[1] != 0
        -:  430:      // therefore we have not finished
        -:  431:      // rover child could be null
       53:  432:      if (rover->child == NULL) {
        2:  433:        return False; // no more children, therefore it can't be found
        -:  434:      }
       51:  435:      return dictLookupN(rover->child,&word[1]); // move to the subproblem :)
        -:  436:    } else {
       53:  437:      rover = rover->sibling;
        -:  438:    }
        -:  439:  }
        -:  440:  // if it gets here it means no matches in the siblings
        7:  441:  return False;
        -:  442:}
        -:  443:
        -:  444:bool
       20:  445:dictLookupIter (struct dictionary* dict, char* word) {
       20:  446:  int i = 0; // loop through elements of the word (counts what letter we're on
       20:  447:  struct dictEdge* node = dict->root;
        -:  448:  struct dictEdge* rover;
      100:  449:  while (i != strlen(word)) {
      192:  450:    for (rover = node;
        -:  451:      rover != NULL;
       44:  452:      rover = rover->sibling) {
      115:  453:      if (word[i] == rover->thisChar) { // if equal
       62:  454:        if (word[i + 1] == 0) { 
        9:  455:          if (rover->isTerminal) {
        5:  456:            return True;
        -:  457:          }
        -:  458:        }
       57:  459:        node = rover->child;
       57:  460:        break; // break out of loop
        -:  461:      }
        -:  462:      // if we've reached the end of the word and we haven't found it then
       53:  463:      if (rover->sibling == NULL || word[i] < rover->thisChar) {
        -:  464:        // don't really need the second one but saves time
        9:  465:        return False;
        -:  466:      }
        -:  467:    }
       60:  468:    ++i; // look up the next letter with parent node
        -:  469:  }
        6:  470:  return False;
        -:  471:}
        -:  472:
        -:  473:/* Extract all words in the dictionary (the order does not matter).
        -:  474: * Should return them in alphabetical order
        -:  475: * Complexity: see constraint in the assignment specification.
        -:  476: */
        -:  477:struct wlnode*
        1:  478:dictCompletions (struct dictionary* dict, char* word) {
        1:  479:  return wlRev(distCompletions(dict,word)); // fun fix
        -:  480:  // return distCompletions(dict,word);
        -:  481:}
        -:  482:
        -:  483:/* testing functions for the above */
        -:  484:void
    #####:  485:printwl (struct wlnode* wl) {
        -:  486:   struct wlnode * cur;
    #####:  487:   for (cur = wl; NULL != cur; cur =  cur->next)
    #####:  488:      fprintf (stdout, "%s\n", cur->word);
    #####:  489:}
        -:  490:
        -:  491:/* Erase all dictionary entries and release all memory allocated for the
        -:  492: * dictionary.
        -:  493: */
        -:  494:// Complexity O(n) // linearly dependant on size of trie
        -:  495:void
        1:  496:dictFree (struct dictionary* dict) {
        -:  497:  // free all the nodes then free the dictionary
        1:  498:  edgeFree(dict->root);
        1:  499:  dict->root = NULL;
        1:  500:  free(dict); // freeing the dictionary is easy
        1:  501:}
        -:  502:
        -:  503:// recursively free all the nodes
        -:  504:// Complexity O(n) // linearly dependant on size of trie
        -:  505:void
       71:  506:edgeFree(struct dictEdge *node) {
       71:  507:  if (node != NULL) {   
       35:  508:    edgeFree(node->sibling);
       35:  509:    edgeFree(node->child);
       35:  510:    node->sibling = NULL; // null out the pointers
       35:  511:    node->child = NULL;
       35:  512:    free(node);
        -:  513:  }
       71:  514:}
        -:  515:
        -:  516:/* Return the root of the trie (i.e. dictionary). 
        -:  517: * If the dictionary is empty, then return NULL. 
        -:  518: * Otherwise, return the root of the trie. 
        -:  519: */ // complexity O(1)
        -:  520:struct dictEdge*
    #####:  521:dictGetRoot (struct dictionary* dict) { 
    #####:  522:  return dict->root;
        -:  523:}
        -:  524:
        -:  525:// word list functions below :)
        -:  526:/* This function does NOT do what it says on the tin */
        -:  527:// due to the fact that the initial complexity was O(n)
        -:  528:// Complexity, O(1)
        -:  529:// I was thinking of moving the mallocing to this function but then thought
        -:  530:// I might break something
        -:  531:/* This function inserts a word by reference in the second position, (or first if wlnode is NULL */
        -:  532:struct wlnode* 
       32:  533:wlIns (struct wlnode* wl, char* word) {
       32:  534:  struct wlnode* new = malloc(sizeof(struct wlnode));
       32:  535:  assert(new != NULL);
        -:  536:  // since we store the first node with dictCompletion
       32:  537:  new->word = word;
       32:  538:  if (wl == NULL) {
        4:  539:    new->next = wl;
        4:  540:    wl = new;
        -:  541:  }
        -:  542:  else {
       28:  543:    new->next = wl->next;
       28:  544:    wl->next = new;
        -:  545:  }
       32:  546:  return wl;
        -:  547:}
        -:  548:
        -:  549:// Operation Complexity O(n)
        -:  550:// Space Requirement, O(1)
        -:  551:// In place reversing of a linked list
        -:  552:struct wlnode* 
        2:  553:wlRev(struct wlnode* wl) {
        -:  554:  // done in lab 1
        2:  555:  struct wlnode* new = wlIns(NULL,"");
        2:  556:  struct wlnode* rover = wl;
       33:  557:  while (rover != NULL) {
        -:  558:    // do I get better performance if I store this variable outside the loop?
       29:  559:    struct wlnode* store = rover->next; 
       29:  560:    rover->next = new->next;
       29:  561:    new->next = rover;
       29:  562:    rover = store; 
        -:  563:  }
        2:  564:  rover = new->next; // saves defining another variable :)
        2:  565:  new->next = NULL;
        2:  566:  free(new);
        2:  567:  return rover;
        -:  568:}
        -:  569:
