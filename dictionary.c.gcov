        -:    0:Source:dictionary.c
        -:    0:Graph:dictionary.gcno
        -:    0:Data:dictionary.gcda
        -:    0:Runs:5
        -:    0:Programs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "dictionary.h"
        -:    5:#include <string.h>
        -:    6:
        -:    7:/* Initialise the dictionary structure
        -:    8: */
        -:    9:
        -:   10:struct wlnode* wlRev(struct wlnode*);
        -:   11:void 
    #####:   12:perr(char error[]) {
        -:   13:#define DEBUGP
        -:   14:#ifdef DEBUGP
    #####:   15:  fprintf(stderr,"%s\n",error);
        -:   16:#endif
    #####:   17:}
        -:   18:
        -:   19:
        -:   20:/* 
        -:   21:  unused functions
        -:   22:  used as a basis for the final functions :)
        -:   23:    */
        -:   24:
        -:   25:void printEdge(struct dictEdge* dnode, long n);
        5:   26:void printDict(struct dictionary* dict) {
        5:   27:  printEdge(dict->root,0);
        5:   28:}
        -:   29:
        -:   30:#if 0
        -:   31:void 
        -:   32:dictList(struct dictionary* dict);
        -:   33:
        -:   34:void 
        -:   35:dictListN(struct dictEdge* root,char* word,int level);
        -:   36:
        -:   37:void 
        -:   38:dictList(struct dictionary* dict) {
        -:   39:  dictListN(dict->root,NULL,0);
        -:   40:}
        -:   41:
        -:   42:void dictListN(struct dictEdge* root,char* word,int level) {
        -:   43:  if (root == NULL)
        -:   44:    return;
        -:   45:  printf("%p\n",root);
        -:   46:  // word
        -:   47:  /*
        -:   48:  if (root->isTerminal == True) {
        -:   49:    printf("ISTERMINAL PRINTING OUT WORD len(%d)\n",strlen(word));
        -:   50:    printf("%s\n",word);
        -:   51:  } */
        -:   52:
        -:   53:  dictListN(root->sibling,word,level);
        -:   54: // if (root->thisChar == 0)
        -:   55: // return; 
        -:   56:  assert(root->thisChar != '\0');
        -:   57:
        -:   58:  if (word == NULL) {
        -:   59://    word = malloc(sizeof(char)*2);
        -:   60:    word = malloc(sizeof(char)*82);
        -:   61:    assert(word != NULL);
        -:   62:    // *word = sprintf("%c\0",root->thisChar);
        -:   63:    word[0] = root->thisChar;
        -:   64:    // printf(">%c<",root->thisChar);
        -:   65:    word[1] = 0;
        -:   66:  } else {
        -:   67:    int i = level + 2; // the array size is strlen(word)+1
        -:   68://    word = realloc (word, sizeof(char)*(i));
        -:   69:    word[i-1] = 0;
        -:   70:    word[i-2] = root->thisChar;
        -:   71://    printf("ATTEMPTING TO REALLOC for >%c<",root->thisChar);
        -:   72:    // add the char to the end of word, and/or move the pointer:)
        -:   73:    // printf("%d vs %d\n",i,strlen(word));
        -:   74:  }
        -:   75:  if (root->isTerminal == True) {
        -:   76:    printf("ISTERMINAL PRINTING OUT WORD len(%d)\n",strlen(word));
        -:   77:    printf("%s\n",word);
        -:   78:  }
        -:   79:  dictListN(root->child,word,level+1);
        -:   80:}
        -:   81:#endif
        -:   82:/* begining of true functions */
        -:   83:
        -:   84:// insert into slist and return the head
        -:   85:struct wlnode* 
        -:   86:wlIns(struct wlnode* head,char* word);
        -:   87:
        -:   88:// oop, typo :)
        -:   89:struct wlnode*
        -:   90:distCompletions (struct dictionary* dict,char* word);
        -:   91:void
        -:   92:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:   93:  int level, struct wlnode* head);
        -:   94:
        -:   95:
        -:   96:// converts all the items in a dictionary into a linked list of words
        -:   97:// this isn't that bad
        -:   98:void
    #####:   99:dictToWlNew (struct dictEdge* root,char *store,
        -:  100:  int level, struct wlnode* head) {
    #####:  101:  if (root == NULL) 
    #####:  102:    return;// terminating case :)
    #####:  103:  assert(store != NULL); // store should be defined already
    #####:  104:  int i = level + 2; 
    #####:  105:  store[i-1] = 0;
    #####:  106:  store[i-2] = root->thisChar;
    #####:  107:  if (root->isTerminal == True) {
    #####:  108:    char *str = malloc(sizeof(char)*(level + 2)); 
        -:  109:    // space for new char + null
    #####:  110:    assert(str != NULL); // we have enough memory
    #####:  111:    strcpy(str,store); // copy everything
    #####:  112:    wlIns(head,str);
        -:  113:  } // do it in order :)
    #####:  114:  dictToWlNew (root->child,store,level+1,head);
    #####:  115:  dictToWlNew (root->sibling,store,level,head);
        -:  116:}
        -:  117:
        -:  118:struct wlnode*
    #####:  119:distCompletions (struct dictionary* dict,char* word) {
        -:  120://  printf("strlen of word is %d\n",strlen(word));return;
    #####:  121:  struct wlnode* a = wlIns(NULL,"hi");
        -:  122:  char store[82];
        -:  123:  // this is stupid
    #####:  124:  if (word[0] == 0) { // meaning that the word is blank
        -:  125:    // printf("doing old routine");
    #####:  126:    dictToWlNew(dict->root,store,0,a);
        -:  127:  //  return a->next;
        -:  128:  }
        -:  129:  else {
    #####:  130:    distCompletionsN(dict->root,word,store,0,a);
        -:  131:  }
        -:  132:  // if I want to see where the gap is between words
    #####:  133:  struct wlnode* re = a->next;
    #####:  134:  a->next = NULL;
    #####:  135:  free(a);
    #####:  136:  return re;
        -:  137:}
        -:  138:
        -:  139:void
    #####:  140:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:  141:  int level, struct wlnode* head) {
    #####:  142:  if (root == NULL) {
        -:  143:    // if the root is null we are done!
    #####:  144:    return;
        -:  145:  }
    #####:  146:  assert(store != NULL); // since I declared it before
    #####:  147:  int i = level + 2; // the array size is strlen(word)+1
    #####:  148:  store[i-1] = 0;
    #####:  149:  store[i-2] = root->thisChar; 
        -:  150:  // what this does is append root->thisChar to then end of stored string
        -:  151:  
        -:  152:  // FIX
    #####:  153:  if (root->isTerminal == True) {
    #####:  154:    if (strlen(word) - 1 == level) {
    #####:  155:      if (word[level] == root->thisChar) {
    #####:  156:        char *str = malloc(sizeof(char)*(level + 2));
    #####:  157:        assert(str != NULL);
    #####:  158:        strcpy(str,store);
    #####:  159:        head = wlIns(head,str);
        -:  160:      }
        -:  161:    }
        -:  162:  }
        -:  163:
    #####:  164:  if (root->isTerminal == True) {
    #####:  165:    if (strlen(word) - level == 1 && word[level] == root->thisChar) {
    #####:  166:      printf("maybe I should add %s level: %d\n",word,level);
        -:  167:    }
        -:  168:  }
    #####:  169:  if (root->isTerminal == True 
    #####:  170:    && (word[level] == root->thisChar || level >= strlen(word))
    #####:  171:    && (level >= strlen(word) )) { 
    #####:  172:    if (strlen(store) == 0) {
        -:  173:      // free(store);
        -:  174:      assert(1 != 0);
    #####:  175:      return;
        -:  176://      this looks like a bug
        -:  177:    }
    #####:  178:    printf("adding store %s\n",store);
    #####:  179:    char *str = malloc(sizeof(char)*(level + 2));
        -:  180:/*    char test[level + 2];
        -:  181:    char *str;
        -:  182:    str = test; */ // this code doesn't seem to work at all :(
    #####:  183:    assert(str != NULL);
    #####:  184:    strcpy(str,store);
        -:  185://    printf("adding str %s %p len: %d\n",str,str,strlen(str));
    #####:  186:    head = wlIns(head,str);
        -:  187:  }
    #####:  188:  if (level < strlen(word) && word[level] == root->thisChar) {
        -:  189:   // printf("we have a hit for %c!\n",word[level]);
    #####:  190:    distCompletionsN (root->child,word,store,level+1,head);
    #####:  191:  } else if (level >=strlen(word)) {
        -:  192:    // printf("here");
    #####:  193:    distCompletionsN (root->child,word,store,level+1,head);
        -:  194:    // since I add child first, it is in ORDER :)
    #####:  195:    distCompletionsN (root->sibling,word,store,level,head);
        -:  196:  } else {
    #####:  197:    distCompletionsN (root->sibling,word,store,level,head);
        -:  198:  }
        -:  199:}
        -:  200:// just to test out a few algorithms.
        -:  201:struct wlnode* 
        -:  202:wlIns(struct wlnode* head,char* word);
        -:  203:void 
        -:  204:insertWordR (struct dictEdge * node, char* word);
        -:  205:bool
        -:  206:dictLookupN (struct dictEdge* node,char* word) ;
        -:  207:void
        -:  208:edgeFree(struct dictEdge *node);
        -:  209:struct dictEdge* dictEdgeNew(char thisChar);
        -:  210:void 
        -:  211:printDict(struct dictionary *dict);
        -:  212:
        -:  213:struct dictionary*
        5:  214:dictInit () {
        -:  215:  // we create a new dictionary and then we return it
        5:  216:  struct dictionary* ndict = malloc(sizeof(struct dictionary));
        5:  217:  assert(ndict != NULL); 
        5:  218:  ndict->root = NULL;
        5:  219:  return ndict;
        -:  220:}
        -:  221:
        -:  222:struct dictEdge* 
       59:  223:dictEdgeNew(char thisChar) {
       59:  224:  struct dictEdge *ndictEdge = malloc(sizeof(struct dictEdge));
       59:  225:  assert(ndictEdge != NULL);
       59:  226:  ndictEdge->thisChar = thisChar;
       59:  227:  ndictEdge->child = NULL;
       59:  228:  ndictEdge->sibling = NULL;
       59:  229:  ndictEdge->isTerminal = 0;
       59:  230:  return ndictEdge;
        -:  231:}
        -:  232:    
      123:  233:void printEdge(struct dictEdge* dnode, long n) {
      123:  234:  if (dnode == NULL) {
       64:  235:    return;
        -:  236:  }
        -:  237:  int i;
      294:  238:  for (i=0;i != n;++i)
      235:  239:    printf("  ");
        -:  240:  
       59:  241:  if (dnode->isTerminal == True) {
       30:  242:    printf("\033[1;33m%c\033[m\n",dnode->thisChar);
        -:  243:  } else {
       29:  244:    printf("%c\n",dnode->thisChar);
        -:  245:
        -:  246:  }
       59:  247:  printEdge(dnode->child, n+1); 
       59:  248:  printEdge(dnode->sibling,n);
        -:  249:}
        -:  250:
        -:  251:/* Insert a single word into the dictionary 
        -:  252: */
        -:  253:void
       30:  254:dictInsertWord (struct dictionary* dict, char* word) {
        -:  255:  // assume I'm not in the list.
       30:  256:  if (dict->root == NULL) {
        5:  257:    dict->root = dictEdgeNew(word[0]);
        -:  258:  }
        -:  259:// todo this code still seems bugged like fuck
        -:  260:  // oh my this is icky
        -:  261:  // well, I suppose it's required though
       30:  262:  if (dict->root->thisChar > word[0]) {
    #####:  263:    perr("noes :( fixing node");
    #####:  264:    struct dictEdge* newp = dictEdgeNew(word[0]);
    #####:  265:    newp->sibling = dict->root;
    #####:  266:    dict->root = newp;
        -:  267:  } // TODO, make sure this won't leave any extra nodes
        -:  268://  printf("comparing %d with %d\n",dict->root->thisChar,word[0]);
       30:  269:  assert(dict->root->thisChar <= word[0]); // make sure that the root is okay :)
       30:  270:  insertWordR (dict->root, word); 
       30:  271:}
        -:  272:
        -:  273:
        -:  274:// the amount of time this takes is dependant both on size of word and size of trie
        -:  275:
        -:  276:void 
      126:  277:insertWordR (struct dictEdge * node, char* word) {
      126:  278:  assert(node != NULL);
        -:  279:  // oh I remember again, to prevent against sloppy code ;)
        -:  280:  // passing a null edge is silly
        -:  281:
        -:  282:  /*
        -:  283:  if (word[1] == 0) {
        -:  284:    node->isTerminal = True;
        -:  285:  } */
        -:  286:  // FIX
        -:  287:  // Forgot about insert in order
        -:  288:  /*
        -:  289:  if (word[0] == 0) {
        -:  290:    // terminating
        -:  291:    printf("a triggering\n");
        -:  292:    node->isTerminal = True;
        -:  293:    return;
        -:  294:  }
        -:  295:  */
        -:  296:  // I do believe that kitten's algorithm was a lot better
        -:  297:  //printf("input string-> %s\n",word);
        -:  298:  //char first = word[0];
      126:  299:  bool found = False;
      126:  300:  struct dictEdge* roverPapa = NULL;
        -:  301:  //stopping case, word[0] == \0 // this is a lie!
        -:  302:
      126:  303:  if (word[0] != '\0') {
      126:  304:    struct dictEdge* rover = node;
        -:  305:  
      126:  306:    if (node->thisChar > word[0]) {
    #####:  307:      perr("we have a fucking problem");
    #####:  308:      assert(1 == 0);
        -:  309:    }
        -:  310:
      402:  311:    while (rover != NULL && !found) {
        -:  312:      // we search until we find a match or not
        -:  313:// new
      154:  314:      if (rover->thisChar > word[0]) {
        -:  315:        // ie it's not in the list, since we assume it's ordered
        -:  316:
        -:  317:        // insert it in order
        4:  318:        assert(roverPapa != NULL);
        4:  319:        struct dictEdge* newp = dictEdgeNew(word[0]);
        4:  320:        roverPapa->sibling = newp;
        4:  321:        newp->sibling = rover;
        -:  322:        
        -:  323:        // recurse.
        4:  324:        if (word[1] == 0) {
        2:  325:          newp->isTerminal = True;
        -:  326:        } else {       
        2:  327:          struct dictEdge* newcp = dictEdgeNew(word[1]);
        2:  328:          newp->child = newcp;
        2:  329:          insertWordR(newcp,&word[1]);
        -:  330:        }
        4:  331:        return;
        -:  332:
        -:  333:      }
      150:  334:      if (rover->thisChar == word[0]) {
      117:  335:        found = True;
        -:  336:        // printf("FOUND YAY");
        -:  337:      } else {
       33:  338:        roverPapa = rover;
       33:  339:        rover = rover->sibling;
        -:  340:      }
        -:  341:    }
        -:  342:    // we add it to the end ;)
      122:  343:    if (found == False) { // not found :) && not placed in order
        5:  344:      fprintf(stderr,"not found with arg %s\n",word);
        -:  345:      // just add the whole word in.
        5:  346:      rover = node; 
       12:  347:      while (rover->sibling != NULL) {
        2:  348:        rover = rover->sibling;
        -:  349:      }
        5:  350:      rover->sibling = dictEdgeNew(word[0]);
        5:  351:      node = rover->sibling;
        -:  352:
        5:  353:      int i = 1;
       14:  354:      while (word[i] != 0) {
        4:  355:        struct dictEdge* rover = node;
        -:  356:        int j;
        -:  357:        // terrible code
        -:  358:        // TODO
        6:  359:        for (j=0;j<i-1;j++) {
        2:  360:          assert(rover->child != NULL);
        2:  361:          rover = rover->child;
        -:  362:        }
        4:  363:        rover->child = dictEdgeNew(word[i]);      
        -:  364:     //  printf("new child pointing to %p\n",rover->child);
        4:  365:         ++i;
        4:  366:         if (word[i] == '\0') {
        2:  367:           rover->child->isTerminal = True;
        -:  368:         }
        -:  369:       }
        5:  370:       if (i == 1) { // bug fix.
        -:  371:       // we didn't enter loop
        -:  372:       // then the node is the final element
        3:  373:         node->isTerminal = True;
        -:  374:       } // seems to make sense to put this at the front :) 
        -:  375:       // case for notentering the loop
        -:  376:     }
        -:  377:     else { 
        -:  378:      // found == True
        -:  379:      // looks like a bug here;
      117:  380:      if (rover->child != NULL) {
       64:  381:        if (word[1] == '\0') { 
        8:  382:           printf("HERE"); // tc3 goes here
        8:  383:           rover->isTerminal = True; 
        -:  384:        }
        -:  385:        else {
        -:  386:          // new FIX
        -:  387:          // inorderFix, create the node and set the pointer
       56:  388:          if (rover->child->thisChar > word[1]) {
        -:  389:            // we need to create
        1:  390:            struct dictEdge* newp = dictEdgeNew(word[1]);
        1:  391:            newp->sibling = rover->child;
        1:  392:            rover->child = newp;
        -:  393:          }
       56:  394:          insertWordR(rover->child,&word[1]); 
        -:  395:        }
        -:  396:      }
        -:  397:      else {
        -:  398:        //printf("->>%s\n",word);
       53:  399:        if (word[1] == '\0') { 
       15:  400:           rover->isTerminal = True;
        -:  401:        }
        -:  402:        else {
       38:  403:           rover->child = dictEdgeNew(word[1]);
       38:  404:           insertWordR(rover->child,&word[1]);
        -:  405:           // this could be done with a forloop
        -:  406:           // since all we're doing is spawning children
        -:  407:        }
        -:  408:      }
        -:  409:    }
        -:  410:  }
        -:  411:}
        -:  412:
        -:  413:/* Insert a list of words into the dictionary 
        -:  414: */
        -:  415:void
    #####:  416:dictInsertWords (struct dictionary* dict, struct wlnode* words) {
        -:  417:  // FIX
    #####:  418:  while (words != NULL) {
    #####:  419:    dictInsertWord(dict,words->word);
    #####:  420:    words = words->next;
        -:  421:  }
    #####:  422:}
        -:  423:
        -:  424:/* Check whether a given word is in the dictionary
        -:  425: */
        -:  426:bool
    #####:  427:dictLookup (struct dictionary* dict, char* word) {
        -:  428:  // TODO: this
        -:  429:  // is there a more efficient way.
        -:  430:  // by using two loops, this can be implemented
        -:  431:  // thanks to Ian Craig who showed me :)
    #####:  432:  assert(dict != NULL);
    #####:  433:  return dictLookupN(dict->root,word);
        -:  434:}
        -:  435:
        -:  436:// n for internal? new?
        -:  437:bool
    #####:  438:dictLookupN (struct dictEdge* node,char* word) {
        -:  439:  // todo this code still seems bugged like fuck
    #####:  440:  if (node == NULL) {
        -:  441:    // very special case, dictionary is empty, clearly not in dictionary
    #####:  442:    return False;
        -:  443:  }
        -:  444:  // terminating case.
    #####:  445:  if (word[0] == 0) { // shouldn't really go in here... 
    #####:  446:    return False;
        -:  447:  }
        -:  448:  // if it's the last letter
    #####:  449:  if (word[1] == '\0') {
    #####:  450:      struct dictEdge *rover = node;
        -:  451:      //printf("searching for %c %c\n",word[0],rover->thisChar);
        -:  452:      // while (word[0] < rover->thisChar && rover->sibling != NULL) {
        -:  453:      // while (rover->sibling != NULL && word[0] < rover->thisChar) // damn I had this, it's broken so badly 
    #####:  454:      while (rover->sibling != NULL && word[0] > rover->thisChar) 
        -:  455:      {
        -:  456:// and then it took me a while to figure why it's rover->sibling not rover
        -:  457:        // wow, terrible coding, I didn't even think of the first 
        -:  458:        // check
        -:  459:        //printf("PASS\n");
    #####:  460:        rover = rover->sibling;
        -:  461:      }
    #####:  462:      if (word[0] == rover->thisChar && rover->isTerminal == True) {
    #####:  463:        return True;
        -:  464:      }
        -:  465:      // bugged here
    #####:  466:      return False;
        -:  467:  }
    #####:  468:  struct dictEdge *rover = node;
    #####:  469:  while (rover != NULL) { 
    #####:  470:    if (word[0] == rover->thisChar) {
        -:  471:      // rover child could be null
    #####:  472:      if (rover->child == NULL) {
    #####:  473:        return False; // no more children, therefore it can't be found
        -:  474:      }
    #####:  475:      return dictLookupN(rover->child,&word[1]);
        -:  476:    } else {
    #####:  477:      rover = rover->sibling;
        -:  478:    }
        -:  479:  }
        -:  480:  // if it gets here it means no matches in the siblings
    #####:  481:  return False;
        -:  482:}
        -:  483:
        -:  484:/* Extract all words in the dictionary (the order does not matter).
        -:  485: *
        -:  486: * Complexity: see constraint in the assignment specification.
        -:  487: */
        -:  488:struct wlnode*
    #####:  489:dictCompletions (struct dictionary* dict, char* word) {
    #####:  490:  return wlRev(distCompletions(dict,word));
        -:  491:  return distCompletions(dict,word);
        -:  492:}
        -:  493:
        -:  494:/* testing functions for the above */
        -:  495:void
    #####:  496:printwl (struct wlnode* wl) {
        -:  497:  /*
        -:  498:   struct wlnode * cur;
        -:  499:   for (cur = wl; NULL != cur; cur =  cur->next)
        -:  500:      fprintf (stdout, "%s\n", cur->word);
        -:  501:      */
        -:  502:   struct wlnode * cur;
    #####:  503:   cur = wl;
        -:  504:   //while (cur != NULL && cur != 0x65646e61) {
    #####:  505:   while (cur != NULL) { 
    #####:  506:       cur = cur->next;
    #####:  507:       printf("cur %p\n",cur);
        -:  508:   }
        -:  509:   //return;
        -:  510:   //for (cur = wl; NULL != cur && cur != 0x65646e61; cur = cur->next)
    #####:  511:   for (cur = wl; NULL != cur; cur = cur->next)
    #####:  512:      fprintf (stdout, "%s %p\n", cur->word, cur->word);
    #####:  513:}
        -:  514:
        -:  515:
        -:  516:/* Erase all dictionary entries and release all memory allocated for the
        -:  517: * dictionary.
        -:  518: */
        -:  519:void
    #####:  520:dictFree (struct dictionary* dict) {
        -:  521:  // the plan, free all the nodes then free the dictionary :)
    #####:  522:  edgeFree(dict->root);
        -:  523:  // free the dictionary is easy
    #####:  524:  free(dict);
    #####:  525:}
        -:  526:
        -:  527:// internal call
        -:  528:// recursively free all the nodes
        -:  529:// Complexity O(n) // linearly dependant on size of trie
        -:  530:void
    #####:  531:edgeFree(struct dictEdge *node) {
    #####:  532:  if (node != NULL) {   
    #####:  533:    edgeFree(node->sibling);
    #####:  534:    edgeFree(node->child);
    #####:  535:    node->sibling = NULL;
    #####:  536:    node->child = NULL;
    #####:  537:    free(node);
        -:  538:  }
    #####:  539:}
        -:  540:
        -:  541:/* Return the root of the trie (i.e. dictionary). 
        -:  542: * If the dictionary is empty, then return NULL. 
        -:  543: * Otherwise, return the root of the trie. 
        -:  544: */ // complexity O(1)
        -:  545:struct dictEdge*
    #####:  546:dictGetRoot (struct dictionary* dict) { 
    #####:  547:  return dict->root;
        -:  548:}
        -:  549:
        -:  550:// word list functions below :)
        -:  551:
        -:  552:/*
        -:  553:struct wlnode* 
        -:  554:wlIns (struct wlnode* wl, char* word) {
        -:  555:  struct wlnode* new = malloc(sizeof(struct wlnode));
        -:  556:  // something about this routine looks strange to me :$
        -:  557:  assert(new != NULL);
        -:  558:  new->word = word;
        -:  559:  new->next = NULL;
        -:  560:  if (wl == NULL) {
        -:  561:    wl = new;
        -:  562:  }
        -:  563:  else {
        -:  564:    struct wlnode* rover = wl; // coming back to this, I
        -:  565:    // was just thinking, what the heck am I doing here ;D
        -:  566:    // since there was no requirement for it to be ordered
        -:  567:    while (rover->next != NULL) {
        -:  568:      rover = rover->next;
        -:  569:    }
        -:  570:    rover->next = new;
        -:  571:  }
        -:  572:  return wl;
        -:  573:}*/
        -:  574:
        -:  575:
        -:  576:/* This function does NOT do what it says on the tin :) */
        -:  577:// due to the fact that the initial complexity was O(n)
        -:  578:// Complexity, O(1)
        -:  579:struct wlnode* 
    #####:  580:wlIns (struct wlnode* wl, char* word) {
    #####:  581:  struct wlnode* new = malloc(sizeof(struct wlnode));
    #####:  582:  assert(new != NULL);
        -:  583:  // since we store the first node with dictCompletion
    #####:  584:  new->word = word;
    #####:  585:  if (wl == NULL) {
    #####:  586:    new->next = wl;
    #####:  587:    wl = new;
        -:  588:  }
        -:  589:  else {
    #####:  590:    new->next = wl->next;
    #####:  591:    wl->next = new;
        -:  592:  }
    #####:  593:  return wl;
        -:  594:}
        -:  595:
    #####:  596:struct wlnode* wlRev(struct wlnode* wl) {
        -:  597:  // done in lab 1
    #####:  598:  struct wlnode* new = wlIns(NULL,"");
    #####:  599:  struct wlnode* rover = wl;
        -:  600:  /*
        -:  601:  for (rover = wl;rover != NULL;rover = rover->next) {
        -:  602:    rover->next = new->next;
        -:  603:    new->next = rover;
        -:  604:    
        -:  605:  } */
    #####:  606:  while (rover != NULL) {
    #####:  607:    struct wlnode* store = rover->next; 
        -:  608:      // do I get better performance if I store this variable outside the loop?
    #####:  609:    rover->next = new->next;
    #####:  610:    new->next = rover;
    #####:  611:    rover = store; 
        -:  612:  }
    #####:  613:  rover = new->next;
    #####:  614:  new->next = NULL;
    #####:  615:  free(new);
    #####:  616:  return rover;
        -:  617:}
        -:  618:
        -:  619://unused
        -:  620:// Complexity O(n)
        -:  621:void
    #####:  622:wlfree (struct wlnode* wl) {
    #####:  623:  if (wl == NULL) {
    #####:  624:    return;
        -:  625:  }
    #####:  626:  wlfree(wl->next);
    #####:  627:  free(wl);
        -:  628:}
