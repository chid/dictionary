        -:    0:Source:dictionary.c
        -:    0:Graph:dictionary.gcno
        -:    0:Data:dictionary.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "dictionary.h"
        -:    5:#include <string.h>
        -:    6:
        -:    7:/* xkcd.com/844 describes this code perfectly */
        -:    8:/*
        -:    9:  the way I should have coded this was write two functions
        -:   10:
        -:   11:  lookupAndReturnNode (struct dictionary *dict, char *word)
        -:   12:    which returns the final node that could be found
        -:   13:    and also the levels it has traversed (no of times it called node->child)
        -:   14:
        -:   15:  generateWl (dictEdge *node, char* prefix)
        -:   16:    which returns a wordlist of all words under node
        -:   17:    and prepending the prefix
        -:   18:
        -:   19:  after these two functions are written, all other functions can be called just by using these two
        -:   20:
        -:   21:  lookup
        -:   22:    lookupAndReturnNode
        -:   23:    if (strlen(word) == i + 1) // i indexed from 0
        -:   24:      return True
        -:   25:    return False
        -:   26:  dictCompletions
        -:   27:    lookupAndReturnNode
        -:   28:    word[i+1] = 0
        -:   29:    generateWl (node, word);
        -:   30:  printdict
        -:   31:    generateWl (node, "")
        -:   32:    printwl (wl)
        -:   33:  insert
        -:   34:    lookupAndReturnNode
        -:   35:    while (i < strlen(word))
        -:   36:      node->child = dictEdgeNew(word[i + 1])
        -:   37:      node = node->child
        -:   38:      ++i
        -:   39:
        -:   40:  should've written it all iteratively
        -:   41:*/
        -:   42:
        -:   43:struct wlnode* wlRev(struct wlnode*);
        -:   44:void 
        1:   45:perr(char error[]) {
        -:   46:#define DEBUGP
        -:   47:#ifdef DEBUGP
        1:   48:  fprintf(stderr,"%s\n",error);
        -:   49:#endif
        1:   50:}
        -:   51:
        -:   52:/* 
        -:   53:  unused functions
        -:   54:  used as a basis for the final functions :)
        -:   55:    */
        -:   56:
        -:   57:void printEdge(struct dictEdge* dnode, long n);
    #####:   58:void printDict(struct dictionary* dict) {
    #####:   59:  printEdge(dict->root,0);
    #####:   60:}
        -:   61:/* begining of true functions */
        -:   62:
        -:   63:// insert into slist and return the head
        -:   64:struct wlnode* 
        -:   65:wlIns(struct wlnode* head,char* word);
        -:   66:
        -:   67:// oops, typo :)
        -:   68:struct wlnode*
        -:   69:distCompletions (struct dictionary* dict,char* word);
        -:   70:void
        -:   71:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:   72:  int level, struct wlnode* head);
        -:   73:
        -:   74:// converts all the items in a dictionary into a linked list of words
        -:   75:// this isn't that bad
        -:   76:void
    #####:   77:dictToWlNew (struct dictEdge* root,char *store,
        -:   78:  int level, struct wlnode* head) {
    #####:   79:  if (root == NULL) 
    #####:   80:    return;// terminating case :)
    #####:   81:  assert(store != NULL); // store should be defined already
    #####:   82:  int i = level + 2; 
        -:   83:  // space for new char + null
    #####:   84:  store[i-1] = 0;
    #####:   85:  store[i-2] = root->thisChar;
    #####:   86:  if (root->isTerminal == True) {
    #####:   87:    char *str = malloc(sizeof(char)*(level + 2)); 
    #####:   88:    assert(str != NULL); // we have enough memory
    #####:   89:    strcpy(str,store); // copy everything
    #####:   90:    wlIns(head,str);
        -:   91:  } // do it in order :)
    #####:   92:  dictToWlNew (root->child,store,level+1,head);
    #####:   93:  dictToWlNew (root->sibling,store,level,head);
        -:   94:}
        -:   95:
        -:   96:// Sorry about that, it's a bit dodgy the ordering
        -:   97:struct wlnode*
        1:   98:distCompletions (struct dictionary* dict,char* word) {
        1:   99:  struct wlnode* a = wlIns(NULL,"");
        -:  100:  char store[82];
        1:  101:  store[0] = 0; // do I need this? // this is stupid
        1:  102:  if (word[0] == 0) { // meaning that the word is blank
    #####:  103:    dictToWlNew(dict->root,store,0,a);
        -:  104:  }
        -:  105:  else {
        1:  106:    distCompletionsN(dict->root,word,store,0,a);
        -:  107:  }
        1:  108:  struct wlnode* re = a->next;
        1:  109:  a->next = NULL;
        1:  110:  free(a);
        1:  111:  return re;
        -:  112:}
        -:  113:
        -:  114:void
        6:  115:distCompletionsN (struct dictEdge* root,char* word,char *store,
        -:  116:  int level, struct wlnode* head) {
        6:  117:  if (root == NULL) {
        1:  118:    return; // if the root is null we are done!
        -:  119:  }
        5:  120:  assert(store != NULL); // since I declared it before
        5:  121:  int i = level + 2; // the array size is strlen(word)+1
        5:  122:  store[i-1] = 0;
        5:  123:  store[i-2] = root->thisChar; 
        -:  124:  // what this does is append root->thisChar to then end of stored string
        -:  125:  // FIX
        -:  126:
        5:  127:  if (root->isTerminal == True) {
        1:  128:    if (strlen(word) - 1 == level) {
        1:  129:      if (word[level] == root->thisChar) {
        1:  130:        char *str = malloc(sizeof(char)*(level + 2));
        1:  131:        assert(str != NULL);
        1:  132:        strcpy(str,store);
        1:  133:        head = wlIns(head,str);
        -:  134:      }
        -:  135:    }
        -:  136:  }
        -:  137:
        7:  138:  if (root->isTerminal == True // signifying end of word
        6:  139:    && (word[level] == root->thisChar || level >= strlen(word)) 
        1:  140:    && (level >= strlen(word) )) { 
        -:  141:    
    #####:  142:    if (strlen(store) == 0) {
    #####:  143:      return; // since the string is empty, we don't add it
        -:  144:    }
        -:  145:    // printf("adding store %s\n",store);
    #####:  146:    char *str = malloc(sizeof(char)*(level + 2));
    #####:  147:    assert(str != NULL);
    #####:  148:    strcpy(str,store);
    #####:  149:    head = wlIns(head,str);
        -:  150:  } // just because we added a word doesn't mean we're finished!
        -:  151:
        8:  152:  if (level < strlen(word) && word[level] == root->thisChar) {
        -:  153:    // case what we're looking for is directly below
        -:  154:    
        3:  155:    distCompletionsN (root->child,word,store,level+1,head);
        2:  156:  } else if (level >=strlen(word)) {
        -:  157:    // if we've already 'made it' past checking the word
        -:  158:    // level is 0 indexed, strlen starts at 1 (so to speak)
        -:  159:    // hence the equality
    #####:  160:    distCompletionsN (root->child,word,store,level+1,head);
        -:  161:    // since I add child first, it is in ORDER :)
    #####:  162:    distCompletionsN (root->sibling,word,store,level,head);
        -:  163:  } else {
        -:  164:    // go onto the next sibling then
        2:  165:    distCompletionsN (root->sibling,word,store,level,head);
        -:  166:  } 
        -:  167:  /* these three cases
        -:  168:
        -:  169:  */
        -:  170:}
        -:  171:// just to test out a few algorithms.
        -:  172:struct wlnode* 
        -:  173:wlIns(struct wlnode* head,char* word);
        -:  174:void 
        -:  175:insertWordR (struct dictEdge * node, char* word);
        -:  176:bool
        -:  177:dictLookupN (struct dictEdge* node,char* word) ;
        -:  178:void
        -:  179:edgeFree(struct dictEdge *node);
        -:  180:struct dictEdge* dictEdgeNew(char thisChar);
        -:  181:void 
        -:  182:printDict(struct dictionary *dict);
        -:  183:
        -:  184:/* Initialise the dictionary structure
        -:  185: */
        -:  186:struct dictionary*
        1:  187:dictInit () {
        -:  188:  // we create a new dictionary and then we return it
        1:  189:  struct dictionary* ndict = malloc(sizeof(struct dictionary));
        1:  190:  assert(ndict != NULL); 
        1:  191:  ndict->root = NULL;
        1:  192:  return ndict;
        -:  193:}
        -:  194:
        -:  195:struct dictEdge* 
       33:  196:dictEdgeNew(char thisChar) {
       33:  197:  struct dictEdge *ndictEdge = malloc(sizeof(struct dictEdge));
       33:  198:  assert(ndictEdge != NULL);
       33:  199:  ndictEdge->thisChar = thisChar;
       33:  200:  ndictEdge->child = NULL;
       33:  201:  ndictEdge->sibling = NULL;
       33:  202:  ndictEdge->isTerminal = 0;
       33:  203:  return ndictEdge;
        -:  204:}
        -:  205:    
    #####:  206:void printEdge(struct dictEdge* dnode, long n) {
    #####:  207:  if (dnode == NULL) {
    #####:  208:    return;
        -:  209:  }
        -:  210:  int i;
    #####:  211:  for (i=0;i != n;++i)
    #####:  212:    printf("  ");
        -:  213:  
    #####:  214:  if (dnode->isTerminal == True) {
    #####:  215:    printf("\033[1;33m%c\033[m\n",dnode->thisChar);
        -:  216:  } else {
    #####:  217:    printf("%c\n",dnode->thisChar);
        -:  218:
        -:  219:  }
    #####:  220:  printEdge(dnode->child, n+1); 
    #####:  221:  printEdge(dnode->sibling,n);
        -:  222:}
        -:  223:
        -:  224:/* Insert a single word into the dictionary 
        -:  225: */
        -:  226:void
        8:  227:dictInsertWord (struct dictionary* dict, char* word) {
        -:  228:  // assume I'm not in the list.
        8:  229:  if (dict->root == NULL) {
        1:  230:    dict->root = dictEdgeNew(word[0]);
        -:  231:  }
        -:  232:// todo this code still seems bugged like fuck
        -:  233:  // oh my this is icky
        -:  234:  // well, I suppose it's required though
        8:  235:  if (dict->root->thisChar > word[0]) {
        1:  236:    perr("noes :( fixing node");
        1:  237:    struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  238:    newp->sibling = dict->root;
        1:  239:    dict->root = newp;
        -:  240:  } // TODO, make sure this won't leave any extra nodes
        -:  241://  printf("comparing %d with %d\n",dict->root->thisChar,word[0]);
        8:  242:  assert(dict->root->thisChar <= word[0]); // make sure that the root is okay :)
        8:  243:  insertWordR (dict->root, word); 
        8:  244:}
        -:  245:
        -:  246:
        -:  247:// the amount of time this takes is dependant both on size of word and size of trie
        -:  248:
        -:  249:void 
       25:  250:insertWordR (struct dictEdge * node, char* word) {
       25:  251:  assert(node != NULL);
        -:  252:  // oh I remember again, to prevent against sloppy code ;)
        -:  253:  // passing a null edge is silly
        -:  254:
        -:  255:  /*
        -:  256:  if (word[1] == 0) {
        -:  257:    node->isTerminal = True;
        -:  258:  } */
        -:  259:  // FIX
        -:  260:  // Forgot about insert in order
        -:  261:  /*
        -:  262:  if (word[0] == 0) {
        -:  263:    // terminating
        -:  264:    printf("a triggering\n");
        -:  265:    node->isTerminal = True;
        -:  266:    return;
        -:  267:  }
        -:  268:  */
        -:  269:  // I do believe that kitten's algorithm was a lot better
        -:  270:  //printf("input string-> %s\n",word);
        -:  271:  //char first = word[0];
       25:  272:  bool found = False;
       25:  273:  struct dictEdge* roverPapa = NULL;
        -:  274:  //stopping case, word[0] == \0 // this is a lie!
        -:  275:
       25:  276:  if (word[0] != '\0') {
       25:  277:    struct dictEdge* rover = node;
        -:  278:  
       25:  279:    if (node->thisChar > word[0]) {
    #####:  280:      perr("we have a fucking problem");
    #####:  281:      assert(1 == 0);
        -:  282:    }
        -:  283:
       85:  284:    while (rover != NULL && !found) {
        -:  285:      // we search until we find a match or not
        -:  286:// new
       36:  287:      if (rover->thisChar > word[0]) {
        -:  288:        // ie it's not in the list, since we assume it's ordered
        -:  289:
        -:  290:        // insert it in order
        1:  291:        assert(roverPapa != NULL);
        1:  292:        struct dictEdge* newp = dictEdgeNew(word[0]);
        1:  293:        roverPapa->sibling = newp;
        1:  294:        newp->sibling = rover;
        -:  295:        
        -:  296:        // recurse.
        1:  297:        if (word[1] == 0) {
    #####:  298:          newp->isTerminal = True;
        -:  299:        } else {       
        1:  300:          struct dictEdge* newcp = dictEdgeNew(word[1]);
        1:  301:          newp->child = newcp;
        1:  302:          insertWordR(newcp,&word[1]);
        -:  303:        }
        1:  304:        return;
        -:  305:
        -:  306:      }
       35:  307:      if (rover->thisChar == word[0]) {
       20:  308:        found = True;
        -:  309:        // printf("FOUND YAY");
        -:  310:      } else {
       15:  311:        roverPapa = rover;
       15:  312:        rover = rover->sibling;
        -:  313:      }
        -:  314:    }
        -:  315:    // we add it to the end ;)
       24:  316:    if (found == False) { // not found :) && not placed in order
        4:  317:      fprintf(stderr,"not found with arg %s\n",word);
        -:  318:      // just add the whole word in.
        4:  319:      rover = node; 
       11:  320:      while (rover->sibling != NULL) {
        3:  321:        rover = rover->sibling;
        -:  322:      }
        4:  323:      rover->sibling = dictEdgeNew(word[0]);
        4:  324:      node = rover->sibling;
        -:  325:
        4:  326:      int i = 1;
       21:  327:      while (word[i] != 0) {
       13:  328:        struct dictEdge* rover = node;
        -:  329:        int j;
        -:  330:        // terrible code
        -:  331:        // TODO
       35:  332:        for (j=0;j<i-1;j++) {
       22:  333:          assert(rover->child != NULL);
       22:  334:          rover = rover->child;
        -:  335:        }
       13:  336:        rover->child = dictEdgeNew(word[i]);      
        -:  337:     //  printf("new child pointing to %p\n",rover->child);
       13:  338:         ++i;
       13:  339:         if (word[i] == '\0') {
        4:  340:           rover->child->isTerminal = True;
        -:  341:         }
        -:  342:       }
        4:  343:       if (i == 1) { // bug fix.
        -:  344:       // we didn't enter loop
        -:  345:       // then the node is the final element
    #####:  346:         node->isTerminal = True;
        -:  347:       } // seems to make sense to put this at the front :) 
        -:  348:       // case for notentering the loop
        -:  349:     }
        -:  350:     else { 
        -:  351:      // found == True
        -:  352:      // looks like a bug here;
       20:  353:      if (rover->child != NULL) {
        5:  354:        if (word[1] == '\0') { 
    #####:  355:           printf("HERE"); // tc3 goes here
    #####:  356:           rover->isTerminal = True; 
        -:  357:        }
        -:  358:        else {
        -:  359:          // new FIX
        -:  360:          // inorderFix, create the node and set the pointer
        5:  361:          if (rover->child->thisChar > word[1]) {
        -:  362:            // we need to create
        1:  363:            struct dictEdge* newp = dictEdgeNew(word[1]);
        1:  364:            newp->sibling = rover->child;
        1:  365:            rover->child = newp;
        -:  366:          }
        5:  367:          insertWordR(rover->child,&word[1]); 
        -:  368:        }
        -:  369:      }
        -:  370:      else {
        -:  371:        //printf("->>%s\n",word);
       15:  372:        if (word[1] == '\0') { 
        4:  373:           rover->isTerminal = True;
        -:  374:        }
        -:  375:        else {
       11:  376:           rover->child = dictEdgeNew(word[1]);
       11:  377:           insertWordR(rover->child,&word[1]);
        -:  378:           // this could be done with a forloop
        -:  379:           // since all we're doing is spawning children
        -:  380:        }
        -:  381:      }
        -:  382:    }
        -:  383:  }
        -:  384:}
        -:  385:
        -:  386:/* Insert a list of words into the dictionary 
        -:  387: */
        -:  388:void
    #####:  389:dictInsertWords (struct dictionary* dict, struct wlnode* words) {
    #####:  390:  while (words != NULL) {
    #####:  391:    dictInsertWord(dict,words->word); // icky
    #####:  392:    words = words->next;
        -:  393:  }
    #####:  394:}
        -:  395:
        -:  396:/* Check whether a given word is in the dictionary
        -:  397: */
        -:  398:bool
    #####:  399:dictLookup (struct dictionary* dict, char* word) {
        -:  400:  // is there a more efficient way.
        -:  401:  // by using two loops, this can be implemented
        -:  402:  // thanks to Ian Craig who showed me :)
    #####:  403:  assert(dict != NULL);
    #####:  404:  return dictLookupN(dict->root,word);
        -:  405:}
        -:  406:
        -:  407:// n for internal? new?
        -:  408:bool
    #####:  409:dictLookupN (struct dictEdge* node,char* word) {
        -:  410:  // todo this code still seems bugged like fuck
        -:  411:  // terminating case. // dictionary/word is NULL/\0
    #####:  412:  if (node == NULL) {
        -:  413:    // very special case, dictionary is empty, clearly not in dictionary
    #####:  414:    return False;
        -:  415:  }
    #####:  416:  if (word[0] == 0) { // shouldn't really go in here... 
    #####:  417:    return False;
        -:  418:  }
        -:  419:
    #####:  420:  if (word[1] == '\0') {  // if it's the last letter
    #####:  421:      struct dictEdge *rover = node;
        -:  422:      //printf("searching for %c %c\n",word[0],rover->thisChar);
        -:  423:      // while (word[0] < rover->thisChar && rover->sibling != NULL) 
        -:  424:      // while (rover->sibling != NULL && word[0] < rover->thisChar) // damn I had this, it's broken so badly 
    #####:  425:      while (rover->sibling != NULL && word[0] > rover->thisChar) 
        -:  426:      {
        -:  427:        // and then it took me a while to figure why it's rover->sibling not rover
        -:  428:        // wow, terrible coding, I didn't even think of the first 
        -:  429:        // check
        -:  430:        //printf("PASS\n");
    #####:  431:        rover = rover->sibling;
        -:  432:      }
    #####:  433:      if (word[0] == rover->thisChar && rover->isTerminal == True) {
    #####:  434:        return True;
        -:  435:      }
        -:  436:      // bugged here
    #####:  437:      return False;
        -:  438:  }
    #####:  439:  struct dictEdge *rover = node;
    #####:  440:  while (rover != NULL) { 
    #####:  441:    if (word[0] == rover->thisChar) {
        -:  442:      // if we are here we know that word[1] != 0
        -:  443:      // therefore we have not finished
        -:  444:      // rover child could be null
    #####:  445:      if (rover->child == NULL) {
    #####:  446:        return False; // no more children, therefore it can't be found
        -:  447:      }
    #####:  448:      return dictLookupN(rover->child,&word[1]); // move to the subproblem :)
        -:  449:    } else {
    #####:  450:      rover = rover->sibling;
        -:  451:    }
        -:  452:  }
        -:  453:  // if it gets here it means no matches in the siblings
    #####:  454:  return False;
        -:  455:}
        -:  456:
        -:  457:bool
    #####:  458:dictLookupIter (struct dictionary* dict, char* word) {
    #####:  459:  int i = 0; // loop through elements of the word (counts what letter we're on
    #####:  460:  struct dictEdge* node = dict->root;
        -:  461:  struct dictEdge* rover;
    #####:  462:  while (i != strlen(word)) {
    #####:  463:    for (rover = node;
        -:  464:      rover != NULL;
    #####:  465:      rover = rover->sibling) {
    #####:  466:      if (word[i] == rover->thisChar) { // if equal
    #####:  467:        if (word[i + 1] == 0) { 
    #####:  468:          if (rover->isTerminal) {
    #####:  469:            return True;
        -:  470:          }
        -:  471:        }
    #####:  472:        node = rover->child;
    #####:  473:        break; // break out of loop
        -:  474:      }
        -:  475:      // if we've reached the end of the word and we haven't found it then
    #####:  476:      if (rover->sibling == NULL || word[i] < rover->thisChar) {
        -:  477:        // don't really need the second one but saves time
    #####:  478:        return False;
        -:  479:      }
        -:  480:    }
    #####:  481:    ++i; // look up the next letter with parent node
        -:  482:  }
    #####:  483:  return False;
        -:  484:}
        -:  485:
        -:  486:/* Extract all words in the dictionary (the order does not matter).
        -:  487: * Should return them in alphabetical order
        -:  488: * Complexity: see constraint in the assignment specification.
        -:  489: */
        -:  490:struct wlnode*
        1:  491:dictCompletions (struct dictionary* dict, char* word) {
        1:  492:  return wlRev(distCompletions(dict,word)); // fun fix
        -:  493:  // return distCompletions(dict,word);
        -:  494:}
        -:  495:
        -:  496:/* testing functions for the above */
        -:  497:void
    #####:  498:printwl (struct wlnode* wl) {
        -:  499:   struct wlnode * cur;
    #####:  500:   for (cur = wl; NULL != cur; cur =  cur->next)
    #####:  501:      fprintf (stdout, "%s\n", cur->word);
    #####:  502:}
        -:  503:
        -:  504:/* Erase all dictionary entries and release all memory allocated for the
        -:  505: * dictionary.
        -:  506: */
        -:  507:// Complexity O(n) // linearly dependant on size of trie
        -:  508:void
        1:  509:dictFree (struct dictionary* dict) {
        -:  510:  // free all the nodes then free the dictionary
        1:  511:  edgeFree(dict->root);
        1:  512:  dict->root = NULL;
        1:  513:  free(dict); // freeing the dictionary is easy
        1:  514:}
        -:  515:
        -:  516:// recursively free all the nodes
        -:  517:// Complexity O(n) // linearly dependant on size of trie
        -:  518:void
       67:  519:edgeFree(struct dictEdge *node) {
       67:  520:  if (node != NULL) {   
       33:  521:    edgeFree(node->sibling);
       33:  522:    edgeFree(node->child);
       33:  523:    node->sibling = NULL; // null out the pointers
       33:  524:    node->child = NULL;
       33:  525:    free(node);
        -:  526:  }
       67:  527:}
        -:  528:
        -:  529:/* Return the root of the trie (i.e. dictionary). 
        -:  530: * If the dictionary is empty, then return NULL. 
        -:  531: * Otherwise, return the root of the trie. 
        -:  532: */ // complexity O(1)
        -:  533:struct dictEdge*
    #####:  534:dictGetRoot (struct dictionary* dict) { 
    #####:  535:  return dict->root;
        -:  536:}
        -:  537:
        -:  538:// word list functions below :)
        -:  539:/* This function does NOT do what it says on the tin */
        -:  540:// due to the fact that the initial complexity was O(n)
        -:  541:// Complexity, O(1)
        -:  542:// I was thinking of moving the mallocing to this function but then thought
        -:  543:// I might break something
        -:  544:/* This function inserts a word by reference in the second position, (or first if wlnode is NULL */
        -:  545:struct wlnode* 
        4:  546:wlIns (struct wlnode* wl, char* word) {
        4:  547:  struct wlnode* new = malloc(sizeof(struct wlnode));
        4:  548:  assert(new != NULL);
        -:  549:  // since we store the first node with dictCompletion
        4:  550:  new->word = word;
        4:  551:  if (wl == NULL) {
        3:  552:    new->next = wl;
        3:  553:    wl = new;
        -:  554:  }
        -:  555:  else {
        1:  556:    new->next = wl->next;
        1:  557:    wl->next = new;
        -:  558:  }
        4:  559:  return wl;
        -:  560:}
        -:  561:
        -:  562:// Operation Complexity O(n)
        -:  563:// Space Requirement, O(1)
        -:  564:// In place reversing of a linked list
        -:  565:struct wlnode* 
        2:  566:wlRev(struct wlnode* wl) {
        -:  567:  // done in lab 1
        2:  568:  struct wlnode* new = wlIns(NULL,"");
        2:  569:  struct wlnode* rover = wl;
        5:  570:  while (rover != NULL) {
        -:  571:    // do I get better performance if I store this variable outside the loop?
        1:  572:    struct wlnode* store = rover->next; 
        1:  573:    rover->next = new->next;
        1:  574:    new->next = rover;
        1:  575:    rover = store; 
        -:  576:  }
        2:  577:  rover = new->next; // saves defining another variable :)
        2:  578:  new->next = NULL;
        2:  579:  free(new);
        2:  580:  return rover;
        -:  581:}
        -:  582:
